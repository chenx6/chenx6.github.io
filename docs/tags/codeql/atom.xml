<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh_CN">
	<title>二进制咸鱼的自我救赎 - codeql</title>
	<subtitle>幸福往往是摸的透彻，而敬业的心却常常隐藏。</subtitle>
	<link href="https://chenx6.github.io/tags/codeql/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://chenx6.github.io/"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2020-04-20T00:00:00+00:00</updated>
	<id>https://chenx6.github.io/tags/codeql/atom.xml</id>
	<entry xml:lang="zh_CN">
		<title>CodeQL 体验</title>
		<published>2020-04-20T00:00:00+00:00</published>
		<updated>2020-04-20T00:00:00+00:00</updated>
		<link rel="alternate" href="https://chenx6.github.io/post/codeql/" type="text/html"/>
		<id>https://chenx6.github.io/post/codeql/</id>
		<content type="html">&lt;h2 id=&quot;概要&quot;&gt;概要&lt;&#x2F;h2&gt;
&lt;p&gt;之前在 Twitter 上看到有大佬说 Github Learning Club 上搞了个免费的 CodeQL 课程，课程最终目标是使用 CodeQL 这个语言找出 uboot 中的 9 个漏洞。我在克服拖延症后，终于在 4 月底完成了这个课程，于是写文记录。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;lab.github.com&#x2F;githubtraining&#x2F;codeql-u-boot-challenge-(cc++)&quot;&gt;课程链接&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;securitylab.github.com&#x2F;research&#x2F;uboot-rce-nfs-vulnerability&quot;&gt;通过 CodeQL 找出来的漏洞分析&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;提前准备&quot;&gt;提前准备&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;VSCode  &#x2F;&#x2F; VSC 天下第一&lt;&#x2F;li&gt;
&lt;li&gt;本机上的 Git 和 Github 帐号  &#x2F;&#x2F; 废话&lt;&#x2F;li&gt;
&lt;li&gt;在线翻译  &#x2F;&#x2F; 文档和课程的英文文本量有点大&lt;&#x2F;li&gt;
&lt;li&gt;C&#x2F;C++ 基础  &#x2F;&#x2F; 不会 C 语言怎么挖洞啊&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;环境搭建&quot;&gt;环境搭建&lt;&#x2F;h2&gt;
&lt;p&gt;首先先在课程链接中选择 &amp;quot;Start free course&amp;quot;，然后 Github 机器人会在你的帐号下新建项目。先将这个项目 Clone 到本地。Github 机器人会通过 Issue 和 Pull request 和你进行沟通。&lt;&#x2F;p&gt;
&lt;p&gt;官方推荐使用 VSCode，那我们就使用 VSC。当然，其他 IDE 应该也是可以的。&lt;&#x2F;p&gt;
&lt;p&gt;然后安装&lt;a href=&quot;https:&#x2F;&#x2F;marketplace.visualstudio.com&#x2F;items?itemName=github.vscode-codeql&quot;&gt;CodeQL 插件&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;CodeQL 插件会自动从 Github 上下载大约 400M 的 codeql-cli，如果下载速度慢请使用加速器。&lt;&#x2F;p&gt;
&lt;p&gt;接下来&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;github&#x2F;vscode-codeql-starter&#x2F;&quot;&gt;Clone 这个项目&lt;&#x2F;a&gt;到本地。这个项目里的 submodule 也须要 Clone。使用下面命令一步到位。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash z-code&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;z-source z-shell z-bash&quot;&gt;&lt;span class=&quot;z-meta z-function-call z-shell&quot;&gt;&lt;span class=&quot;z-variable z-function z-shell&quot;&gt;git&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-arguments z-shell&quot;&gt; clone&lt;span class=&quot;z-variable z-parameter z-option z-shell&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-parameter z-shell&quot;&gt; --&lt;&#x2F;span&gt;recursive&lt;&#x2F;span&gt; https:&#x2F;&#x2F;github.com&#x2F;github&#x2F;vscode-codeql-starter&#x2F;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在 VSCode 菜单中点击 &lt;code&gt;File &amp;gt; Open Workspace&lt;&#x2F;code&gt; 选择 &lt;code&gt;vscode-codeql-starter.code-workspace&lt;&#x2F;code&gt; 这个文件来打开这个工作区。&lt;&#x2F;p&gt;
&lt;p&gt;从&lt;a href=&quot;https:&#x2F;&#x2F;downloads.lgtm.com&#x2F;snapshots&#x2F;cpp&#x2F;uboot&#x2F;u-boot_u-boot_cpp-srcVersion_d0d07ba86afc8074d79e436b1ba4478fa0f0c1b5-dist_odasa-2019-07-25-linux64.zip&quot;&gt;这个链接&lt;&#x2F;a&gt;下载已经分析好的 uboot CodeQL 数据库，然后解压到相应的文件夹。&lt;&#x2F;p&gt;
&lt;p&gt;使用 VSCode 快捷键 &amp;quot;ctrl + shift + p&amp;quot; 进入命令模式，输入 &amp;quot;codeql choose database&amp;quot; 看到相应的选项后，点击就可以添加上前面解压的 uboot codeql 数据库。&lt;&#x2F;p&gt;
&lt;p&gt;在前面打开工作区 VSCode 中使用 &lt;code&gt;File -&amp;gt; Add Folder to Workspace&lt;&#x2F;code&gt; 添加前面机器人新建的项目文件夹到当前工作区。&lt;&#x2F;p&gt;
&lt;p&gt;到此环境配置完成。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;第一次查询和_Pull_request&quot;&gt;第一次查询和 Pull request&lt;&#x2F;h2&gt;
&lt;p&gt;机器人创建的项目中有等着我们编辑的空文件和 &lt;code&gt;solution&lt;&#x2F;code&gt; 文件夹。接下来是教程中的第三步，编辑 &lt;code&gt;3_function_definitions.ql&lt;&#x2F;code&gt; 这个文件，借助补全填入下面内容，以查询 &lt;code&gt;strlen&lt;&#x2F;code&gt; 的声明和定义。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ql&quot; class=&quot;language-ql z-code&quot;&gt;&lt;code class=&quot;language-ql&quot; data-lang=&quot;ql&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;import cpp

from Function f
where f.getName() = &amp;quot;strlen&amp;quot;
select f, &amp;quot;a function named strlen&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到 CodeQL 程序的基本架构，第一句 &lt;code&gt;import cpp&lt;&#x2F;code&gt; 导入了 CPP 模块，而后面的 &lt;code&gt;from ... where ... select&lt;&#x2F;code&gt; 就是 CodeQL 程序的基本结构。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;from Function f&lt;&#x2F;code&gt; 这句话声明了 f 是个 Function 类型的变量。Function 是个类，一个类代表了一种数据的集合，而 Function 这个类型代表了待分析代码中的函数集合。&lt;&#x2F;p&gt;
&lt;p&gt;后面的 &lt;code&gt;where ...&lt;&#x2F;code&gt; 中出现的谓词代表了我们想查询的逻辑，而变量 &lt;code&gt;f&lt;&#x2F;code&gt; 后面的 &lt;code&gt;getName&lt;&#x2F;code&gt; 是谓词，他表达了我们查询的逻辑。在上面的代码中我们找到了所有名字为 &amp;quot;strlen&amp;quot; 的函数。&lt;&#x2F;p&gt;
&lt;p&gt;然后在 VSCode 的命令面板里让命令跑起来，或者对着脚本右键，点击 &amp;quot;Run Query&amp;quot;，进行查询了。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;codeql0.png&quot; alt=&quot;0&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;写完代码后，就是发起 Pull request 了。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash z-code&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;z-source z-shell z-bash&quot;&gt;&lt;span class=&quot;z-comment z-line z-number-sign z-shell&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-begin z-shell&quot;&gt;#&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-comment z-line z-number-sign z-shell&quot;&gt; 拉取 master&lt;&#x2F;span&gt;&lt;span class=&quot;z-comment z-line z-number-sign z-shell&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-shell&quot;&gt;&lt;span class=&quot;z-variable z-function z-shell&quot;&gt;git&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-arguments z-shell&quot;&gt; checkout master&lt;&#x2F;span&gt;
&lt;span class=&quot;z-meta z-function-call z-shell&quot;&gt;&lt;span class=&quot;z-variable z-function z-shell&quot;&gt;git&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-arguments z-shell&quot;&gt; pull&lt;&#x2F;span&gt;
&lt;span class=&quot;z-comment z-line z-number-sign z-shell&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-begin z-shell&quot;&gt;#&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-comment z-line z-number-sign z-shell&quot;&gt; 新建分支，并切换到该分支&lt;&#x2F;span&gt;&lt;span class=&quot;z-comment z-line z-number-sign z-shell&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-shell&quot;&gt;&lt;span class=&quot;z-variable z-function z-shell&quot;&gt;git&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-arguments z-shell&quot;&gt; checkout&lt;span class=&quot;z-variable z-parameter z-option z-shell&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-parameter z-shell&quot;&gt; -&lt;&#x2F;span&gt;b&lt;&#x2F;span&gt; step-4&lt;&#x2F;span&gt;
&lt;span class=&quot;z-comment z-line z-number-sign z-shell&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-begin z-shell&quot;&gt;#&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-comment z-line z-number-sign z-shell&quot;&gt; 进行 commit&lt;&#x2F;span&gt;&lt;span class=&quot;z-comment z-line z-number-sign z-shell&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-shell&quot;&gt;&lt;span class=&quot;z-variable z-function z-shell&quot;&gt;git&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-arguments z-shell&quot;&gt; add .&lt;&#x2F;span&gt;
&lt;span class=&quot;z-meta z-function-call z-shell&quot;&gt;&lt;span class=&quot;z-variable z-function z-shell&quot;&gt;git&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-arguments z-shell&quot;&gt; commit&lt;span class=&quot;z-variable z-parameter z-option z-shell&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-parameter z-shell&quot;&gt; -&lt;&#x2F;span&gt;a&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-parameter z-option z-shell&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-parameter z-shell&quot;&gt; -&lt;&#x2F;span&gt;m&lt;&#x2F;span&gt; &lt;span class=&quot;z-string z-quoted z-double z-shell&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-string z-begin z-shell&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;Step 4 query&lt;span class=&quot;z-punctuation z-definition z-string z-end z-shell&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;span class=&quot;z-comment z-line z-number-sign z-shell&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-begin z-shell&quot;&gt;#&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-comment z-line z-number-sign z-shell&quot;&gt; 推送分支，可以发起 pull request&lt;&#x2F;span&gt;&lt;span class=&quot;z-comment z-line z-number-sign z-shell&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-shell&quot;&gt;&lt;span class=&quot;z-variable z-function z-shell&quot;&gt;git&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-arguments z-shell&quot;&gt; push&lt;span class=&quot;z-variable z-parameter z-option z-shell&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-parameter z-shell&quot;&gt; -&lt;&#x2F;span&gt;u&lt;&#x2F;span&gt; origin step-4&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;执行完上面的命令后，在 Github 上打开 &amp;quot;codeql-uboot&amp;quot; 项目的 Pull request 标签，就可以看到我们创建了一个新分支，且可以发起 Pull request。在发起 PR 后，会触发 Github Actions，校验答案的时间在 1 到 3 分钟左右。检查完成后就会进行下一步操作了。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;codeql1.png&quot; alt=&quot;1&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;所以在这几分钟内可以看点泡面番，或者打开邦邦清下火（逃&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;导入不同的类完成查询&quot;&gt;导入不同的类完成查询&lt;&#x2F;h2&gt;
&lt;p&gt;前面我们查询了函数，在第五步我们可以通过引入 &amp;quot;Macro&amp;quot; 类查询 &lt;code&gt;ntohl, ntohll, ntohs&lt;&#x2F;code&gt; 这三个转换字节序的宏。代码类似第一次查询，这里使用正则表达式可以缩短查询语句。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ql&quot; class=&quot;language-ql z-code&quot;&gt;&lt;code class=&quot;language-ql&quot; data-lang=&quot;ql&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;import cpp

from Macro m
where m.getName().regexpMatch(&amp;quot;ntoh(s|l|ll)&amp;quot;)
select m
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;使用两个变量来查询调用该函数的位置&quot;&gt;使用两个变量来查询调用该函数的位置&lt;&#x2F;h2&gt;
&lt;p&gt;在代码中的 &lt;code&gt;from&lt;&#x2F;code&gt; 语句处可以声明多个变量，然后在 &lt;code&gt;where&lt;&#x2F;code&gt; 中进行联系，以查询相关函数调用。如果无从下手的话可以看看&lt;a href=&quot;https:&#x2F;&#x2F;help.semmle.com&#x2F;wiki&#x2F;display&#x2F;CBCPP&#x2F;Call+to+function&quot;&gt;使用 CodeQL 查询 C++ 的样例&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ql&quot; class=&quot;language-ql z-code&quot;&gt;&lt;code class=&quot;language-ql&quot; data-lang=&quot;ql&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;import cpp

from FunctionCall call, Function func
where
    call.getTarget() = func and
    func.getName() = &amp;quot;memcpy&amp;quot;
select call
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;查看宏的顶层表达&quot;&gt;查看宏的顶层表达&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;应该是展开宏吧...但是英文原文是 &amp;quot;Gets a top-level expression associated with this macro invocation&amp;quot;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;通过 &lt;code&gt;MacroInvocation&lt;&#x2F;code&gt; 这个类来查询 &amp;quot;ntohs&amp;quot; 等宏的调用，并通过 &lt;code&gt;getExpr()&lt;&#x2F;code&gt; 这个方法进行宏的展开，得到相应的代码片段。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ql&quot; class=&quot;language-ql z-code&quot;&gt;&lt;code class=&quot;language-ql&quot; data-lang=&quot;ql&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;import cpp

from MacroInvocation mi
where mi.getMacro().getName().regexpMatch(&amp;quot;ntoh(s|l|ll)&amp;quot;)
select mi.getExpr()

&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;自己实现一个类&quot;&gt;自己实现一个类&lt;&#x2F;h2&gt;
&lt;p&gt;前面&lt;a href=&quot;#&quot;&gt;第一次查询&lt;&#x2F;a&gt;说了，一个类代表了一种数据的集合。通过实现一个自己的类，能自定义一个自己想要的数据集合。如果有点懵可以看看 CodeQL 关于类的&lt;a href=&quot;https:&#x2F;&#x2F;help.semmle.com&#x2F;QL&#x2F;ql-handbook&#x2F;types.html#classes&quot;&gt;相关文档&lt;&#x2F;a&gt;。查询语句中的类中，先通过 &lt;code&gt;exists&lt;&#x2F;code&gt; 量词创建一个临时变量 &lt;code&gt;mi&lt;&#x2F;code&gt; 来表示被调用的宏的名字，如果被调用的的宏展开后和当前代码片段相等，则这个表达式属于这个集合。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ql&quot; class=&quot;language-ql z-code&quot;&gt;&lt;code class=&quot;language-ql&quot; data-lang=&quot;ql&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;import cpp

class NetworkByteSwap extends Expr {
  NetworkByteSwap() {
    exists(MacroInvocation mi |
      mi.getMacroName().regexpMatch(&amp;quot;ntoh(s|l|ll)&amp;quot;) and
      this = mi.getExpr()
    )
  }
}

from NetworkByteSwap n
select n, &amp;quot;Network byte swap&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;数据流和污点追踪&quot;&gt;数据流和污点追踪&lt;&#x2F;h2&gt;
&lt;p&gt;借助前面几步，我们基本了解了 CodeQL 的使用。最后一个测试是使用 CodeQL 进行污点追踪。这里使用了 CodeQL 的全局污点追踪(Global taint tracking)。可以先看看&lt;a href=&quot;https:&#x2F;&#x2F;help.semmle.com&#x2F;QL&#x2F;learn-ql&#x2F;cpp&#x2F;dataflow.html&quot;&gt;使用 CodeQL 追踪数据流的文档&lt;&#x2F;a&gt;了解相关概念。新定义的 &lt;code&gt;Config&lt;&#x2F;code&gt; 类继承于 &lt;code&gt;TaintTracking::Configuration&lt;&#x2F;code&gt;。类中重载的 &lt;code&gt;isSource&lt;&#x2F;code&gt; 谓语定义为污点的源头，而 &lt;code&gt;isSink&lt;&#x2F;code&gt; 定义为污点的去处。&lt;&#x2F;p&gt;
&lt;p&gt;有时候，远程输入的数据可能经过 &lt;code&gt;ntoh&lt;&#x2F;code&gt; 函数处理，通过转换字节序得到相应的数字。而 &lt;code&gt;memcpy&lt;&#x2F;code&gt; 的第 2 个参数如果控制不当，可造成数据溢出。将上面两个结论结合起来，如果有一个远程输入的数据通过字节序变换得到的数字，在未经过校验的情况下，作为了 &lt;code&gt;memcpy&lt;&#x2F;code&gt; 的第二个参数，那么就有可能造成数据溢出。&lt;&#x2F;p&gt;
&lt;p&gt;照着 &lt;a href=&quot;https:&#x2F;&#x2F;securitylab.github.com&#x2F;research&#x2F;cve-2018-4259-macos-nfs-vulnerability&quot;&gt;Github 自家安全团队的文章&lt;&#x2F;a&gt;，可以照猫画虎的补全数据查询语句。&lt;&#x2F;p&gt;
&lt;p&gt;在 &lt;code&gt;isSource&lt;&#x2F;code&gt; 中，我们通过判断 &lt;code&gt;source&lt;&#x2F;code&gt; 的 &lt;code&gt;Expr&lt;&#x2F;code&gt; 是否是 &lt;code&gt;NetworkByteSwap&lt;&#x2F;code&gt; 这个类，来判断污点的源头。&lt;&#x2F;p&gt;
&lt;p&gt;在 &lt;code&gt;isSink&lt;&#x2F;code&gt; 中，我们使用了辅助类 &lt;code&gt;FunctionCall&lt;&#x2F;code&gt; 判断函数调用是否为 &lt;code&gt;memcpy&lt;&#x2F;code&gt; 且 &lt;code&gt;sink&lt;&#x2F;code&gt; 的代码片段是否为 &lt;code&gt;memcpy&lt;&#x2F;code&gt; 的第二个参数；最后一句则是判断函数的第一个参数是否为常量，如果为常量的话基本不可能出现问题，所有忽略。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ql&quot; class=&quot;language-ql z-code&quot;&gt;&lt;code class=&quot;language-ql&quot; data-lang=&quot;ql&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;&#x2F;**
 * @kind path-problem
 *&#x2F;

import cpp
import semmle.code.cpp.dataflow.TaintTracking
import DataFlow::PathGraph

class NetworkByteSwap extends Expr {
  NetworkByteSwap() {
    exists(MacroInvocation mi |
      mi.getMacroName().regexpMatch(&amp;quot;ntoh(s|l|ll)&amp;quot;) and
      this = mi.getExpr()
    )
  }
}

class Config extends TaintTracking::Configuration {
  Config() { this = &amp;quot;NetworkToMemFuncLength&amp;quot; }

  override predicate isSource(DataFlow::Node source) { source.asExpr() instanceof NetworkByteSwap }

  override predicate isSink(DataFlow::Node sink) {
    exists(FunctionCall call |
      call.getTarget().getName() = &amp;quot;memcpy&amp;quot; and
      sink.asExpr() = call.getArgument(2) and
      not call.getArgument(1).isConstant()
    )
  }
}

from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink
where cfg.hasFlowPath(source, sink)
select sink, source, sink, &amp;quot;Network byte swap flows to memcpy&amp;quot;

&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;codeql2.png&quot; alt=&quot;2&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;点击查询结果就可以跳转到代码位置，以进行详细分析。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;codeql3.png&quot; alt=&quot;3&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这里就是 Github 展示的漏洞，对 nfs 请求的回复长度未经过校验，导致可以控制 nfs_path 的 2048 字节。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;refs&quot;&gt;refs&lt;&#x2F;h2&gt;
&lt;p&gt;CodeQL 教程 &lt;a href=&quot;https:&#x2F;&#x2F;help.semmle.com&#x2F;QL&#x2F;learn-ql&#x2F;&quot;&gt;https:&#x2F;&#x2F;help.semmle.com&#x2F;QL&#x2F;learn-ql&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
