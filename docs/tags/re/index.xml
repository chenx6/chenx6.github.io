<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>re on 二进制咸鱼的自我救赎</title>
    <link>https://chenx6.github.io/tags/re/</link>
    <description>Recent content in re on 二进制咸鱼的自我救赎</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <lastBuildDate>Tue, 05 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://chenx6.github.io/tags/re/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>plt hook 项目代码分析和最小实现</title>
      <link>https://chenx6.github.io/post/plthook/</link>
      <pubDate>Tue, 05 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://chenx6.github.io/post/plthook/</guid>
      <description>虽然知道可以通过魔改 plt 表实现 hook 函数，但是不知道具体实现&amp;hellip;碰巧最近用到了 plthook 这个库，于是我就研究了下 plthook 这个库，并且仿照着这个库重新实现一份代码。 原理分析 根据命名规则，.rela.plt 表是负</description>
    </item>
    
    <item>
      <title>重写 OLLVM 之控制流平坦化</title>
      <link>https://chenx6.github.io/post/rewrite_ollvm_fla/</link>
      <pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://chenx6.github.io/post/rewrite_ollvm_fla/</guid>
      <description>OLLVM 的控制流平坦化是逆向老哥最讨厌的混淆了，因为一旦使用就代表着 IDA 的 decompiler 彻底报废了。所以了解并在自己的项目中重写控制流平坦化挺重要的。 什么是控制流平坦化 名词解释 BasicBlock 代码块，以跳转语句结尾的一段代码。 语言描述</description>
    </item>
    
    <item>
      <title>CodeQL 体验</title>
      <link>https://chenx6.github.io/post/codeql/</link>
      <pubDate>Mon, 20 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://chenx6.github.io/post/codeql/</guid>
      <description>概要 之前在 Twitter 上看到有大佬说 Github Learning Club 上搞了个免费的 CodeQL 课程，课程最终目标是使用 CodeQL 这个语言找出 uboot 中的 9 个漏洞。我在克服拖延症后，终于在 4 月底完成了这个课程，于是写文记录。 课程链接 通过 CodeQL 找出来的漏洞分析 提前准备</description>
    </item>
    
    <item>
      <title>使用 LLVM Pass 实现字符串加密</title>
      <link>https://chenx6.github.io/post/obfuscate_string/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://chenx6.github.io/post/obfuscate_string/</guid>
      <description>这个项目可以作为我看了这么久 LLVM 的 Docs 助眠的一个小总结吧。这个项目主要就是给函数使用的常量字符串进行加密，在程序被静态分析的时候干扰分析。当然找到思路后，这个混淆还是很容易解开的。 吐槽下，网上的文章质量参</description>
    </item>
    
    <item>
      <title>在 LLVM 代码树外编译 LLVM Pass (使用 OLLVM 示范)</title>
      <link>https://chenx6.github.io/post/build_pass_out_of_tree/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://chenx6.github.io/post/build_pass_out_of_tree/</guid>
      <description>在网络上流传的编译 LLVM Pass 都需要一份 LLVM 源码，从整个源代码编译，编译非常花时间 (i7 6700HQ 使用 make -j8 编译整个项目花了近 50 分钟)，所以在翻阅文档时发现 LLVM 支持在代码树外编译，在 1 分钟内编译一个 Pass，还是非常香的。 项目</description>
    </item>
    
    <item>
      <title>给 ELF 文件加上后门</title>
      <link>https://chenx6.github.io/post/elf_backdoor/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://chenx6.github.io/post/elf_backdoor/</guid>
      <description>在渗透测试中，给常用的可执行文件加上后门是很常见的操作。但是之前的加后门 &amp;ldquo;The backdoor factory&amp;rdquo; 已经不维护了，而且还是 Python2 写的，代码质量也&amp;hellip;所以我自己尝试着重新用 Python3 造了个轮子。在造轮子的过程中，由于 APUE 扔在学</description>
    </item>
    
    <item>
      <title>重写 OLLVM 之虚假控制流</title>
      <link>https://chenx6.github.io/post/rewrite_ollvm_bcf/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://chenx6.github.io/post/rewrite_ollvm_bcf/</guid>
      <description>由于我个人觉得 OLLVM 的代码年久失修，所以就新建了个项目，开始学习并重写 OLLVM。项目地址：https://github.com/chenx6/baby_obfuscator。如果将我的重写项目和 OLLVM 相比的</description>
    </item>
    
  </channel>
</rss>
